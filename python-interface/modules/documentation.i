// File: index.xml

// File: classlal_1_1generate_1_1____rand__lab__free__trees.xml


%feature("docstring") lal::generate::__rand_lab_free_trees "
`__rand_lab_free_trees(n, seed=0)`  
`__rand_lab_free_trees(Gen)`  

Random labelled free tree generator.  

**Users should refrain from using this class.** The generation of random
labelled trees should be done using the wrapper class rand_lab_free_trees. This
class, however, contains the actual code to generate labelled free trees
uniformly at random.  

This class implements an algorithm that uses uniformly random Pr√ºfer sequences
(see [22]). The construction of the free labelled tree uses the algorithm in
[4].  

Constructors
------------
* `__rand_lab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled free tree generator.  

C++ includes: rand_lab_free_trees.hpp
";

%feature("docstring") lal::generate::__rand_lab_free_trees::__rand_lab_free_trees "

Overloaded function
-------------------
* `__rand_lab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled free tree generator.  
";

%feature("docstring") lal::generate::__rand_lab_free_trees::~__rand_lab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::__rand_lab_free_trees::get_tree "

Returns a labelled free tree chosen uniformly at random.  
";

// File: classlal_1_1generate_1_1____rand__lab__rooted__trees.xml


%feature("docstring") lal::generate::__rand_lab_rooted_trees "
`__rand_lab_rooted_trees(n, seed=0)`  
`__rand_lab_rooted_trees(Gen)`  

Random labelled directed rooted trees generator.  

**Users should refrain from using this class.** The generation of random
labelled trees should be done using the wrapper class rand_lab_rooted_trees.
This class, however, contains the actual code to generate labelled rooted trees
uniformly at random.  

These trees are generated by first generating uniformly at random a free
labelled tree. Then, a node of the generated tree is chosen uniformly at random.
This node plays the role of the root of the rooted labelled tree. The edges are
oriented away from the root.  

Constructors
------------
* `__rand_lab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled rooted tree generator.  

C++ includes: rand_lab_rooted_trees.hpp
";

%feature("docstring") lal::generate::__rand_lab_rooted_trees::__rand_lab_rooted_trees "

Overloaded function
-------------------
* `__rand_lab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled rooted tree generator.  
";

%feature("docstring") lal::generate::__rand_lab_rooted_trees::~__rand_lab_rooted_trees "

Default destructor.  
";

%feature("docstring") lal::generate::__rand_lab_rooted_trees::get_tree "

Generates uniformly at random a labelled rooted tree.  

Returns
-------
A labelled tree generated uniformly at random. The tree is rooted at vertex 0.  
";

// File: classlal_1_1generate_1_1____rand__ulab__free__trees.xml


%feature("docstring") lal::generate::__rand_ulab_free_trees "
`__rand_ulab_free_trees(n, seed=0)`  
`__rand_ulab_free_trees(Gen)`  

Random unlabelled free tree generator.  

**Users should refrain from using this class.** The generation of random
labelled trees should be done using the wrapper class rand_ulab_free_trees. This
class, however, contains the actual code to generate labelled rooted trees
uniformly at random.  

Every call to get_tree generates uniformly at random an unlabelled free tree
using the algorithm described in [27]. This algorithm relies on the ranrut
procedure (see [20], chapter 29) and runs in about the same time. The
implementation of Wilf's paper (see [27]) in functions get_tree, forest, and
bicenter includes the correction pointed out in [19] (page 38).  

Constructors
------------
* `__rand_ulab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled free tree generator.  

C++ includes: rand_ulab_free_trees.hpp
";

%feature("docstring") lal::generate::__rand_ulab_free_trees::__rand_ulab_free_trees "

Overloaded function
-------------------
* `__rand_ulab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `__rand_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled free tree generator.  
";

%feature("docstring") lal::generate::__rand_ulab_free_trees::~__rand_ulab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::__rand_ulab_free_trees::get_tree "

Generates uniformly at random a free unlabelled tree.  

Includes the correction in Wilf's paper (see [27]), as pointed out in [19].  

Returns
-------
An unlabelled free tree.  
";

// File: classlal_1_1generate_1_1____rand__ulab__rooted__trees.xml


%feature("docstring") lal::generate::__rand_ulab_rooted_trees "
`__rand_ulab_rooted_trees(n, seed=0)`  
`__rand_ulab_rooted_trees(Gen)`  

Random unlabelled rooted tree generator.  

**Users should refrain from using this class.** The generation of random
labelled trees should be done using the wrapper class rand_ulab_rooted_trees.
This class, however, contains the actual code to generate labelled rooted trees
uniformly at random.  

Every call to get_tree generates rooted unlabelled trees uniformly at random
using the *ranrut* procedure (see [20], chapter 29).  

Constructors
------------
* `__rand_ulab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `__rand_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled rooted tree generator.  

C++ includes: rand_ulab_rooted_trees.hpp
";

%feature("docstring") lal::generate::__rand_ulab_rooted_trees::__rand_ulab_rooted_trees "

Overloaded function
-------------------
* `__rand_ulab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `__rand_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled rooted tree generator.  
";

%feature("docstring") lal::generate::__rand_ulab_rooted_trees::~__rand_ulab_rooted_trees "

Destructor.  
";

%feature("docstring") lal::generate::__rand_ulab_rooted_trees::get_tree "

Generates uniformly at random a free unlabelled tree.  

Returns
-------
An unlabelled rooted tree. The tree is rooted at vertex 0.  
";

%feature("docstring") lal::generate::__rand_ulab_rooted_trees::clear "

Clears the memory occupied.  

In order to save computation time, this class has been designed to reuse memory
when generating trees. For example, since it needs the values of well-known
integer sequences (see attribute m_rn) that are costly to compute every time
they are needed, they are stored in memory and reused over time.  

So, if the user wants to generate trees of 1000 nodes there will be too much
memory occupied (and unused) if then this class is used to generate trees of 10
nodes. In cases like this it is recommended to clear the memory occupied.  

post: After calling this method, the contents of the attributes m_rn are
    cleared. Attribute m_rn is then assigned the same 31 values that it is
    assigned when creating an object of this class.  
";

// File: classlal_1_1generate_1_1all__lab__free__trees.xml


%feature("docstring") lal::generate::all_lab_free_trees "
`all_lab_free_trees(n)`  
`all_lab_free_trees(Gen)`  

Exhaustive labelled free tree generator.  

Generates all the labelled free trees of a given number of nodes. The algorithm
implemented uses Pr√ºfer sequences (see [22]) and decodes them using the
algorithm in [4].  

In order to use this class, you must first provide the size :math:`n` of the tree
(number of nodes) in the constructor or in the init method of the trees to be
generated.  

Then, call method next to modify the internal state that will allow the user to
construct the tree by calling method get_tree.  

All the free labelled trees have been generated when method has_next returns
false. At this point, method get_tree will always construct a star tree of :math:`n` nodes.  

In order to restart the generation of these trees, call method init again. It is
allowed, at any time, to call init with the same size of the trees, or with a
different one.  

The correct usage of this class is  

Constructors
------------
* `all_lab_free_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive labelled free tree generator..  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: all_lab_free_trees.hpp
";

%feature("docstring") lal::generate::all_lab_free_trees::all_lab_free_trees "

Overloaded function
-------------------
* `all_lab_free_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive labelled free tree generator..  
";

%feature("docstring") lal::generate::all_lab_free_trees::~all_lab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::all_lab_free_trees::has_next "

Returns whether there are more trees to generate.  

Returns
-------
True if there are still more trees to generate. Returns false if all trees have
been generated (there are no more unique trees of this size that were not
generated before).  
";

%feature("docstring") lal::generate::all_lab_free_trees::next "

Generates next tree.  

Modifies the internal state so that the next tree can be retrieved using method
get_tree().  

pre: The generator must have been initialised.  
";

%feature("docstring") lal::generate::all_lab_free_trees::reset "

Sets the generator to its initial state.  

This method can be called anytime.  
";

%feature("docstring") lal::generate::all_lab_free_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1all__lab__rooted__trees.xml


%feature("docstring") lal::generate::all_lab_rooted_trees "
`all_lab_rooted_trees(n)`  
`all_lab_rooted_trees(Gen)`  

Exhaustive labelled rooted tree generator.  

This class enumerates all labelled rooted trees of a given number of vertices.
It is based on the labelled free trees generator (see all_lab_free_trees).  

The correct usage of this class is  

Constructors
------------
* `all_lab_rooted_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive labelled rooted tree generator..  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: all_lab_rooted_trees.hpp
";

%feature("docstring") lal::generate::all_lab_rooted_trees::all_lab_rooted_trees "

Overloaded function
-------------------
* `all_lab_rooted_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive labelled rooted tree generator..  
";

%feature("docstring") lal::generate::all_lab_rooted_trees::~all_lab_rooted_trees "

Default destructor.  
";

%feature("docstring") lal::generate::all_lab_rooted_trees::has_next "

Returns whether there are more trees to generate.  

Returns
-------
True if there are still more trees to generate. Returns false if all trees have
been generated (there are no more unique trees of this size that were not
generated before).  
";

%feature("docstring") lal::generate::all_lab_rooted_trees::next "

Generates next tree.  

Modifies the internal state so that the next tree can be retrieved using method
get_tree().  

pre: The generator must have been initialised.  
";

%feature("docstring") lal::generate::all_lab_rooted_trees::reset "

Sets the generator to its initial state.  

This method can be called anytime.  
";

%feature("docstring") lal::generate::all_lab_rooted_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1all__projective__arrangements.xml


%feature("docstring") lal::generate::all_projective_arrangements "
`all_projective_arrangements(T)`  
`all_projective_arrangements(Gen)`  

Exhaustive projective arrangement generator.  

Generates all projective arrangements of a given rooted tree.  

The arrangements generated do not take into account the symmetrical arrangements
produced by swapping leaves of the tree connected to the same parent. That is,
the arrangements produced can be seen as labelled arrangements. Therefore, this
class will generate :math:`n!` arrangements for all star trees of :math:`n` vertices.  

The correct usage of this class is  

Constructors
------------
* `all_projective_arrangements(T)`  
    
    Constructor with constant reference to a rooted tree.  

    Parameters:
  
    * `T` :  
        Rooted tree  

    pre: The object *T* is a valid rooted tree (see
        graphs::rooted_tree::is_rooted_tree).  

    pre: The tree is normalised (see graphs::graph::is_normalised()).  

* `all_projective_arrangements(Gen)`  
    
    Default copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive projective arrangement generator..  

C++ includes: all_projective_arrangements.hpp
";

%feature("docstring") lal::generate::all_projective_arrangements::all_projective_arrangements "

Overloaded function
-------------------
* `all_projective_arrangements(T)`  
    
    Constructor with constant reference to a rooted tree.  

    Parameters:
  
    * `T` :  
        Rooted tree  

    pre: The object *T* is a valid rooted tree (see
        graphs::rooted_tree::is_rooted_tree).  

    pre: The tree is normalised (see graphs::graph::is_normalised()).  

* `all_projective_arrangements(Gen)`  
    
    Default copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive projective arrangement generator..  
";

%feature("docstring") lal::generate::all_projective_arrangements::~all_projective_arrangements "
";

%feature("docstring") lal::generate::all_projective_arrangements::has_next "

Returns whether there are more arrangements to generate.  

Returns
-------
True if there are still more arrangements to generate. Returns false if all
arrangements have been generated.  
";

%feature("docstring") lal::generate::all_projective_arrangements::get_arrangement "

Constructs the current arrangement.  

Returns
-------
The arrangement generated with method next().  

pre: Method next must have been called at least once.  
";

%feature("docstring") lal::generate::all_projective_arrangements::next "

Generates the next arrangement.  

Modifies the internal state so that the next arrangement can be retrieved using
method get_arrangement.  
";

// File: classlal_1_1generate_1_1all__ulab__free__trees.xml


%feature("docstring") lal::generate::all_ulab_free_trees "
`all_ulab_free_trees(n)`  
`all_ulab_free_trees(Gen)`  

Exhaustive unlabelled free tree generator.  

Generates all the unlabelled free trees of a given number of nodes. The
algorithm implemented can be found in [28]. The definition of the public and
private members of this class follow the notation in this work.  

In order to use this class, you must first provide the size :math:`n` of the tree
(number of nodes) in the constructor or in the init method of the trees to be
generated.  

Then, call method next to modify the internal state that will allow the user to
construct the tree by calling method get_tree.  

All the unlabelled free trees have been generated when method has_next returns
false. At this point, method get_tree will always construct a star tree of :math:`n` nodes.  

In order to restart the generation of these trees, call method init again. It is
allowed, at any time, to call init with the same size of the trees, or with a
different one.  

The correct usage of this class is  

Constructors
------------
* `all_ulab_free_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive unlabelled free tree generator..  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: all_ulab_free_trees.hpp
";

%feature("docstring") lal::generate::all_ulab_free_trees::all_ulab_free_trees "

Overloaded function
-------------------
* `all_ulab_free_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive unlabelled free tree generator..  
";

%feature("docstring") lal::generate::all_ulab_free_trees::~all_ulab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::all_ulab_free_trees::has_next "

Returns whether there are more trees to generate.  

Returns
-------
True if there are still more trees to generate. Returns false if all trees have
been generated (there are no more unique trees of this size that were not
generated before).  
";

%feature("docstring") lal::generate::all_ulab_free_trees::next "

Generates next tree.  

Modifies the internal state so that the next tree can be retrieved using method
get_tree.  

pre: The generator must have been initialised.  
";

%feature("docstring") lal::generate::all_ulab_free_trees::reset "

Sets the generator to its initial state.  

This method can be called anytime.  
";

%feature("docstring") lal::generate::all_ulab_free_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1all__ulab__rooted__trees.xml


%feature("docstring") lal::generate::all_ulab_rooted_trees "
`all_ulab_rooted_trees(n)`  
`all_ulab_rooted_trees(Gen)`  

Exhaustive unlabelled rooted tree generator.  

Generates all the unlabelled rooted trees of a given number of nodes. The
algorithm implemented can be found in [5]. The definition of the public and
private members of this class follow the notation in this work.  

In order to use this class, you must first provide the size :math:`n` of the tree
(number of nodes) in the constructor or in the init method of the trees to be
generated.  

Then, call method next to modify the internal state that will allow the user to
construct the tree by calling method get_tree.  

All the unlabelled rooted trees have been generated when method has_next returns
false. At this point, method get_tree will always construct a star tree of :math:`n` nodes rooted at its central node.  

In order to restart the generation of these trees, call method init again. It is
allowed, at any time, to call init with the same size of the trees, or with a
different one.  

The correct usage of this class is  

Constructors
------------
* `all_ulab_rooted_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive unlabelled rooted tree generator..  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: all_ulab_rooted_trees.hpp
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::all_ulab_rooted_trees "

Overloaded function
-------------------
* `all_ulab_rooted_trees(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `all_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Exhaustive unlabelled rooted tree generator..  
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::~all_ulab_rooted_trees "

Default destructor.  
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::has_next "

Returns whether there are more trees to generate.  

Returns
-------
True if there are still more trees to generate. Returns false if all trees have
been generated (there are no more unique trees of this size that were not
generated before).  
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::next "

Generates the next tree.  

Modifies the internal state so that the next tree can be retrieved using method
get_tree.  

pre: The generator must have been initialised.  
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::reset "

Sets the generator to its initial state.  

This method can be called anytime.  
";

%feature("docstring") lal::generate::all_ulab_rooted_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1internal_1_1AVL.xml


%feature("docstring") lal::internal::AVL "
";

%feature("docstring") lal::internal::AVL::~AVL "
";

%feature("docstring") lal::internal::AVL::remove "
";

%feature("docstring") lal::internal::AVL::join_sorted_all_greater "
";

// File: classlal_1_1internal_1_1BFS.xml


%feature("docstring") lal::internal::BFS "
";

%feature("docstring") lal::internal::BFS::BFS "
";

%feature("docstring") lal::internal::BFS::~BFS "
";

%feature("docstring") lal::internal::BFS::reset "
";

%feature("docstring") lal::internal::BFS::start_at "

Overloaded function
-------------------
* `start_at(source)`  

* `start_at(sources)`  
";

%feature("docstring") lal::internal::BFS::set_use_rev_edges "
";

%feature("docstring") lal::internal::BFS::set_terminate_default "
";

%feature("docstring") lal::internal::BFS::set_terminate "
";

%feature("docstring") lal::internal::BFS::set_process_current_default "
";

%feature("docstring") lal::internal::BFS::set_process_current "
";

%feature("docstring") lal::internal::BFS::set_process_neighbour_default "
";

%feature("docstring") lal::internal::BFS::set_process_neighbour "
";

%feature("docstring") lal::internal::BFS::set_node_add_default "
";

%feature("docstring") lal::internal::BFS::set_node_add "
";

%feature("docstring") lal::internal::BFS::set_process_visited_neighbours "
";

%feature("docstring") lal::internal::BFS::reset_visited "
";

%feature("docstring") lal::internal::BFS::clear_structure "
";

%feature("docstring") lal::internal::BFS::set_visited "
";

%feature("docstring") lal::internal::BFS::node_was_visited "
";

%feature("docstring") lal::internal::BFS::all_visited "
";

%feature("docstring") lal::internal::BFS::get_graph "
";

%feature("docstring") lal::internal::BFS::get_visited "
";

// File: structlal_1_1internal_1_1data__array.xml


%feature("docstring") lal::internal::data_array "

Attributes
----------
* `data` : `T *`  
";

%feature("docstring") lal::internal::data_array::data_array "

Overloaded function
-------------------
* `data_array(n)`  

* `data_array(n, v)`  

* `data_array(d)`  

* `data_array(d)`  
";

%feature("docstring") lal::internal::data_array::~data_array "
";

%feature("docstring") lal::internal::data_array::size "
";

%feature("docstring") lal::internal::data_array::fill "
";

%feature("docstring") lal::internal::data_array::begin "

Overloaded function
-------------------
* `begin()`  

* `begin()`  
";

%feature("docstring") lal::internal::data_array::end "

Overloaded function
-------------------
* `end()`  

* `end()`  
";

// File: classlal_1_1linarr_1_1dependency__flux.xml


%feature("docstring") lal::linarr::dependency_flux "

Dependency flux.  

The dependency flux of a dependency tree, as defined in [18].  

C++ includes: dependency_flux.hpp
";

%feature("docstring") lal::linarr::dependency_flux::get_left_span "

Returns left span of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_right_span "

Returns right span of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_size "

Returns the size of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_weight "

Returns weight of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_dependencies "

Returns the set of dependencies.  
";

%feature("docstring") lal::linarr::dependency_flux::get_RL_ratio_rational "

Returns the R/L ratio.  

This is the m_right_span divided by the m_left_span.  

Returns
-------
The R/L ratio of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_RL_ratio "

Returns the R/L ratio.  

This is the m_right_span divided by the m_left_span.  

Returns
-------
The R/L ratio of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_WS_ratio_rational "

Returns the W/S ratio.  

Also known as *density*, this is the m_weight divided by the size of
m_dependencies.  

Returns
-------
The W/S ratio of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::get_WS_ratio "

Returns the W/S ratio.  

Also known as *density*, this is the m_weight divided by the size of
m_dependencies.  

Returns
-------
The W/S ratio of this flux.  
";

%feature("docstring") lal::linarr::dependency_flux::set_left_span "

Sets the left span.  
";

%feature("docstring") lal::linarr::dependency_flux::set_right_span "

Sets the right span.  
";

%feature("docstring") lal::linarr::dependency_flux::set_weight "

Sets the weight.  
";

%feature("docstring") lal::linarr::dependency_flux::set_dependencies "

Sets the set of dependencies.  
";

// File: classlal_1_1graphs_1_1directed__graph.xml


%feature("docstring") lal::graphs::directed_graph "
`directed_graph()`  
`directed_graph(n)`  
`directed_graph(g)`  

Directed graph class.  

Class implementing a directed graph, using the adjacency list data structure.  

An object of this class must be initialised either with its constructor or with
the init(uint32_t) method. Edges can then be added one by one (see
add_edge(node,node,bool,bool) ) or all at the same time (see add_edges(const
std::vector<edge>&, bool,bool) ).  

Constructors
------------
* `directed_graph()`  
    
    Empty constructor.  

* `directed_graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `directed_graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Directed graph.  

C++ includes: directed_graph.hpp
";

%feature("docstring") lal::graphs::directed_graph::directed_graph "

Overloaded function
-------------------
* `directed_graph()`  
    
    Empty constructor.  

* `directed_graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `directed_graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Directed graph.  
";

%feature("docstring") lal::graphs::directed_graph::~directed_graph "

Destructor.  
";

%feature("docstring") lal::graphs::directed_graph::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::directed_graph::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::directed_graph::add_edge "

Adds a directed edge to the graph.  

For developers: method graph::extra_work_per_edge_add is called after the edge
has been added.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Normalise the graph after the insertion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: :math:`u \\neq v`  The directed edge :math:`(s,t)` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::add_edge_bulk "

Adds an edge to the graph.  

This method only adds an edge, and does no other work: normalisation is not
checked, and no extra work per edge is done.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   

pre: :math:`u \\neq v`   

pre: The edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::finish_bulk_add "

Completes the inner structure of the graph after adding a bulk of edges.  

This is meant to be used after several calls to undirected_graph::add_edge_bulk,
directed_graph::add_edge_bulk.  

Parameters
----------
* `norm` :  
    Normalise the graph  
* `check` :  
    Check wether the graph is normalised or not.  
";

%feature("docstring") lal::graphs::directed_graph::add_edges "

Adds a list of directed edges to the graph.  

This operation is faster than adding edges one by one with
add_edge(node,node,bool,bool) since the edges are added in bulk.  

For developers: method graph::extra_work_per_edge_add is called after each edge
has been added.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::set_edges "

Sets the list of edges to the graph.  

This list of edges is assumed to be all the edges that are going to be added to
this graph. This means that the internal data structures are constructed more
efficiently than when adding edges one by one (see add_edge) or in several
chunks (see add_edges).  

Moreover, the current structure of the graph is cleared before setting the new
edges.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: There are no repeated edges in the list.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::remove_edge "

Remove an edge from this graph.  

For developers: method graph::extra_work_per_edge_remove is called after the
edge has been removed.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: The edge must exist.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::remove_edges "

Remove an edge from this graph.  

This operation is faster than removing edges one by one with
remove_edge(node,node,bool,bool) since the edges are removed in bulk.  

For developers: method graph::extra_work_per_edge_remove is called after each
edge has been removed.  

Parameters
----------
* `edges` :  
    The edges to be deleted.  
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::directed_graph::disjoint_union "

Disjoint union of graphs.  

Given a graph, append it to the current graph.  

All the nodes in *g* are relabelled starting at *n*, the number of nodes of the
current graph.  

Parameters
----------
* `g` :  
    Input graph.  

post: The graph is normalised only if it was normalised before the call and *g*
    is also normalised.  
";

%feature("docstring") lal::graphs::directed_graph::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::directed_graph::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::directed_graph::has_edge "

Returns true if the edge :math:`(u,v)` exists in the graph.  
";

%feature("docstring") lal::graphs::directed_graph::get_out_neighbours "

Returns the out-neighbours of node *u*.  

Parameters
----------
* `u` :  
    Node  

Returns
-------
The list of nodes leaving node *u*.  
";

%feature("docstring") lal::graphs::directed_graph::get_in_neighbours "

Returns the in-neighbours of node *u*.  

Parameters
----------
* `u` :  
    Node  

Returns
-------
The list of nodes entering at node *u*.  
";

%feature("docstring") lal::graphs::directed_graph::degree "

Returns the in-degree plus the out-degree of this vertex.  

Returns the degree of this vertex in its underlying undirected structure. Same
as in_degree + out_degree.  

Parameters
----------
* `u` :  
    Vertex  

Returns
-------
The (in + out) degree of this vertex.  
";

%feature("docstring") lal::graphs::directed_graph::out_degree "

Returns the out-degree of a node.  
";

%feature("docstring") lal::graphs::directed_graph::in_degree "

Returns the in-degree of a node.  
";

%feature("docstring") lal::graphs::directed_graph::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::directed_graph::is_undirected "

Returns whether this graph is undirected or not.  
";

%feature("docstring") lal::graphs::directed_graph::to_undirected "

Converts this directed graph into an undirected graph.  

The undirected graph returned connects two vertices :math:`u,v` if these two vertices
are connected by a directed edge ( :math:`(u,v)` or :math:`(v,u)`  in this graph. In other
words, if two vertices are connected by a single directed edge, the direction is
dropped. If two edges are connected by two directed edges (of opposite
directions) then the two are merged into a single undirected edge.  

Parameters
----------
* `norm` :  
    Normalise the graph.  
* `check` :  
    Chech whether the resulting graph is normalised or not.  

Returns
-------
This graph in which the edges are undirected.  
";

%feature("docstring") lal::graphs::directed_graph::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::directed_graph::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::directed_graph::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::directed_graph::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::directed_graph::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::directed_graph::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::directed_graph::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

// File: classlal_1_1iterators_1_1E__iterator.xml


%feature("docstring") lal::iterators::E_iterator "

Iterator over the set of edges.  

This class is used to easily iterate over the edges of a graph.  

This class iterates over the edges of a graph. For undirected graphs, the edge
returned is an edge :math:`(u,v)` so that the inequality :math:`u < v` always holds. For
directed graphs, this is not always true since the edge returned always has
left-to-right orientation.  

Bear in mind, however, that this class does not modify in any way the graph it
is initialised with.  

The correct usage of this class is  

C++ includes: E_iterator.hpp
";

%feature("docstring") lal::iterators::E_iterator::E_iterator "

Constructor.  

Parameters
----------
* `g` :  
    Constant reference to the graph over which we iterate.  
";

%feature("docstring") lal::iterators::E_iterator::~E_iterator "

Default destructor.  
";

%feature("docstring") lal::iterators::E_iterator::has_next "

Returns true if there are edges left to be iterated over.  
";

%feature("docstring") lal::iterators::E_iterator::get_edge "

Returns the current edge.  
";

%feature("docstring") lal::iterators::E_iterator::next "

Moves the iterator to the next edge.  
";

%feature("docstring") lal::iterators::E_iterator::reset "

Sets the iterator at the beginning of the set of edges.  

post: The next call to method next() returns the first edge of the graph.  
";

// File: classlal_1_1graphs_1_1free__tree.xml


%feature("docstring") lal::graphs::free_tree "
`free_tree()`  
`free_tree(n)`  
`free_tree(t)`  
`free_tree(t)`  

Free tree graph class.  

This class constrains the addition of edges so that the resulting graphs does
not contain cycles. Furthermore, the edges added are undirected.  

For another type of tree-like graphs, see rooted_tree.  

Constructors
------------
* `free_tree()`  
    
    Empty constructor.  

* `free_tree(n)`  
    
    Constructor with number of vertices.  

    Parameters:
  
    * `n` :  
        Number of vertices  

* `free_tree(t)`  
    
    Copy constructor.  

    Parameters:
  
    * `t` :  
        Free tree.  

* `free_tree(t)`  
    
    Copy constructor with undirected graph.  

    Parameters:
  
    * `t` :  
        An undirected graph.  

    pre: Graph *t* is a tree.  

C++ includes: free_tree.hpp
";

%feature("docstring") lal::graphs::free_tree::free_tree "

Overloaded function
-------------------
* `free_tree()`  
    
    Empty constructor.  

* `free_tree(n)`  
    
    Constructor with number of vertices.  

    Parameters:
  
    * `n` :  
        Number of vertices  

* `free_tree(t)`  
    
    Copy constructor.  

    Parameters:
  
    * `t` :  
        Free tree.  

* `free_tree(t)`  
    
    Copy constructor with undirected graph.  

    Parameters:
  
    * `t` :  
        An undirected graph.  

    pre: Graph *t* is a tree.  
";

%feature("docstring") lal::graphs::free_tree::~free_tree "

Destructor.  
";

%feature("docstring") lal::graphs::free_tree::add_edge "

Adds an edge to the tree.  

This operation checks that the edge added does not produce cycles only in a
*debug* compilation of the library. For a more controlled addition of the edges,
see can_add_edge.  

For developers: method graph::extra_work_per_edge_add is called after the edge
has been added.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Should the graph be normalised?  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: :math:`s \\neq t`  

pre: Edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::free_tree::add_edge_bulk "

Adds an edge to the graph.  

This method only adds an edge, and does no other work: normalisation is not
checked, and no extra work per edge is done.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   

pre: :math:`u \\neq v`   

pre: The edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::free_tree::finish_bulk_add "

Finishes adding edges in bulk.  

Parameters
----------
* `norm` :  
    Normalise the tree.  
* `check` :  
    Check whether the tree is normalised or not.  

pre: All edges have been added.  
";

%feature("docstring") lal::graphs::free_tree::add_edges "

Adds a list of edges to the graph.  

This function checks that edges will not produce cycles only in a *debug*
compilation of the library. Moreover, this operation is faster than calling
add_edge since the edges are added in bulk. For a more controlled addition of
the edges, see can_add_edges.  

For developers: method graph::extra_work_per_edge_add is called after each edge
has been added.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method add_edge.  

pre: None of the subsets of the list of edges can produce cycles when added.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edges.  
";

%feature("docstring") lal::graphs::free_tree::set_edges "

Adds a list of edges to the graph.  

This list of edges is assumed to be all the edges that are going to be added to
this graph. This means that the internal data structures are constructed more
efficiently than when adding edges one by one (see add_edge) or in several
chunks (see add_edges). For a more controlled addition of the edges, see
can_add_edges.  

Moreover, the current structure of the graph is cleared before setting the new
edges.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: There are no repeated edges in the list.  

pre: The graph is empty prior to the addition.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::free_tree::disjoint_union "

Overloaded function
-------------------
* `disjoint_union(t)`  
    
    Disjoint union of trees.  

    Given a free tree, append it to the current tree.  

    All the nodes in *t* are relabelled starting at *n*, the number of nodes of
    the current tree.  

    Parameters:
  
    * `t` :  
        Input tree.  

    post: The current tree is not an actual tree, i.e., method is_tree() returns
        false since the resulting tree lacks an edge.  

* `disjoint_union(g)`  
    
    Disjoint union of graphs.  

    Given a graph, append it to the current graph.  

    All the nodes in *g* are relabelled starting at *n*, the number of nodes of
    the current graph.  

    Parameters:
  
    * `g` :  
        Input graph.  

    post: The graph is normalised only if it was normalised before the call and
        *g* is also normalised.  
";

%feature("docstring") lal::graphs::free_tree::calculate_tree_type "

Calculates the type of tree.  

See tree_type for the list of different tree types.  
";

%feature("docstring") lal::graphs::free_tree::is_rooted "

Returns whether this tree is a rooted tree.  
";

%feature("docstring") lal::graphs::free_tree::remove_edge "

Remove an edge from this graph.  

For developers: method graph::extra_work_per_edge_remove is called after the
edge has been removed.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: The edge must exist.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::free_tree::remove_edges "

Remove an edge from this graph.  

This operation is faster than removing edges one by one with
remove_edge(node,node,bool,bool) since the edges are removed in bulk.  

For developers: method graph::extra_work_per_edge_remove is called after each
edge has been removed.  

Parameters
----------
* `edges` :  
    The edges to be deleted.  
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::free_tree::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::free_tree::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::free_tree::get_neighbours "

Returns the neighbourhood of node *u*.  

Parameters
----------
* `u` :  
    Node.  

Returns
-------
The list of nodes adjacent to node *u*.  
";

%feature("docstring") lal::graphs::free_tree::degree "

Returns the number of neighbours of *u*.  

Parameters
----------
* `u` :  
    Node to be queried.  

Returns
-------
The number of adjacent nodes.  
";

%feature("docstring") lal::graphs::free_tree::has_edge "

Returns true if the edge :math:`\\{u,v\\}` exists in the graph.  
";

%feature("docstring") lal::graphs::free_tree::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::free_tree::is_undirected "

Returns whether this graph is undirected or not.  
";

%feature("docstring") lal::graphs::free_tree::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::free_tree::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::free_tree::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::free_tree::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::free_tree::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::free_tree::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::free_tree::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::free_tree::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::free_tree::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

%feature("docstring") lal::graphs::free_tree::is_tree "

Returns whether this graph is an actual tree or not.  

Returns true if the number of edges is one less than the number of nodes. Note
that this would not really be true if the addition of edges was not constrained.
Since it is constrained in a way that no cycles can be produced (for example,
see free_tree::add_edge, or free_tree::add_edges), then we only need to check
for the number of edges.  

For further characterisations of a tree see [13] (chapter 4, pages 32-33).  
";

%feature("docstring") lal::graphs::free_tree::can_add_edge "

Can this edge be added?  

In a tree, an edge can only be added if it does not produce cycles, and it has
not been added before.  

Parameters
----------
* `s` :  
    First node of the edge.  
* `t` :  
    Second node of the edge.  

Returns
-------
Whether the addition of this new edge can be added to the tree without producing
cycles.  
";

%feature("docstring") lal::graphs::free_tree::can_add_edges "

Can these edges be added?  

In a tree, a set of edges can only be added if their addition to the tree do not
produce cycles and none of them have been added before.  

Parameters
----------
* `edges` :  
    List of edges.  

Returns
-------
Whether the addition of these new edges can be added to the tree without
producing cycles.  
";

%feature("docstring") lal::graphs::free_tree::num_nodes_component "

Amount of nodes in a connected component of the tree.  

When tree has had an edge removed, or when it is not completely built, i.e., it
lack some edges, the resulting graph is clearly a forest. This function returns
the size of the forest node *u* belongs to.  

In directed trees one has to see this amount as the number of nodes of the
component in the undirected version of the forest.  

Parameters
----------
* `u` :  
    Input node.  

Returns
-------
The size of the connected component of *u*.  
";

%feature("docstring") lal::graphs::free_tree::is_of_type "

Returns whether this tree is of type *tt*.  
";

%feature("docstring") lal::graphs::free_tree::get_tree_type_list "

Returns the list of types as a list of strings.  

Returns
-------
The list of types as a list of strings.  
";

// File: classlal_1_1graphs_1_1graph.xml


%feature("docstring") lal::graphs::graph "
`graph()`  
`graph(n)`  
`graph(g)`  

Abstract class for graphs.  

Class used as an interface for all types of graphs. This means that this class
cannot be instantiated. The classes that can be instantiated are
undirected_graph, directed_graph, free_tree, rooted_tree.  

A usual way of initialising classes inheriting from this one is to use one of
the init methods available. Depending on the subclass, this method admits either
the number of nodes of the graph or a whole other graph and further information
(see rooted_tree::init_rooted(const free_tree&,node). While these classes'
internal memory can be initialised, it can also be cleared using method clear.
Each class reimplements this method to carry this task appropriately.  

Constructors
------------
* `graph()`  
    
    Empty constructor.  

* `graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Graph.  

C++ includes: graph.hpp
";

%feature("docstring") lal::graphs::graph::graph "

Overloaded function
-------------------
* `graph()`  
    
    Empty constructor.  

* `graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Graph.  
";

%feature("docstring") lal::graphs::graph::~graph "

Destructor.  
";

%feature("docstring") lal::graphs::graph::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::graph::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::graph::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::graph::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::graph::finish_bulk_add "

Completes the inner structure of the graph after adding a bulk of edges.  

This is meant to be used after several calls to undirected_graph::add_edge_bulk,
directed_graph::add_edge_bulk.  

Parameters
----------
* `norm` :  
    Normalise the graph  
* `check` :  
    Check wether the graph is normalised or not.  
";

%feature("docstring") lal::graphs::graph::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::graph::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::graph::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::graph::has_edge "

Returns true if the undirected edge (*u*, *v*) exists in the graph.  
";

%feature("docstring") lal::graphs::graph::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::graph::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::graph::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::graph::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

%feature("docstring") lal::graphs::graph::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::graph::is_undirected "

Returns whether this graph is undirected or not.  
";

// File: classlal_1_1numeric_1_1integer.xml


%feature("docstring") lal::numeric::integer "
`integer()`  
`integer(i)`  
`integer(s)`  
`integer(i)`  

Arbitrary precision integer.  

This class wraps the *mpz_t* data structure from GMP with operators for an easy
usage.  

Constructors
------------
* `integer()`  
    
    Empty constructor.  

* `integer(i)`  
    
    Constructor with unsigned integer value.  

    Parameters:
  
    * `i` :  
        A signed integer (basic type) number.  

* `integer(s)`  
    
    Constructor with string.  

    Parameters:
  
    * `s` :  
        A string.  

* `integer(i)`  
    
    Copy constructor.  

    Parameters:
  
    * `i` :  
        A lal::numeric::integer.  

C++ includes: integer.hpp
";

%feature("docstring") lal::numeric::integer::rational "
";

%feature("docstring") lal::numeric::integer::integer "

Overloaded function
-------------------
* `integer()`  
    
    Empty constructor.  

* `integer(i)`  
    
    Constructor with unsigned integer value.  

    Parameters:
  
    * `i` :  
        A signed integer (basic type) number.  

* `integer(s)`  
    
    Constructor with string.  

    Parameters:
  
    * `s` :  
        A string.  

* `integer(i)`  
    
    Copy constructor.  

    Parameters:
  
    * `i` :  
        A lal::numeric::integer.  
";

%feature("docstring") lal::numeric::integer::~integer "

Destructor.  
";

%feature("docstring") lal::numeric::integer::set_si "

Overwrites the value of this integer with *i*.  

Parameters
----------
* `i` :  
    A signed integer (basic type) number.  
";

%feature("docstring") lal::numeric::integer::set_ui "

Overwrites the value of this integer with *i*.  

Parameters
----------
* `i` :  
    Unsigned integer (basic type) number.  
";

%feature("docstring") lal::numeric::integer::set_integer "

Overwrites the value of this integer with *i*.  

Parameters
----------
* `i` :  
    A lal::numeric::integer.  
";

%feature("docstring") lal::numeric::integer::set_str "

Overwrites the value of this integer with *s*.  

Parameters
----------
* `s` :  
    A string.  
";

%feature("docstring") lal::numeric::integer::is_initialized "

Returns whether this object is initialised or not.  
";

%feature("docstring") lal::numeric::integer::get_sign "

Returns the sign of this integer.  
";

%feature("docstring") lal::numeric::integer::bytes "

Returns the amount of bytes this integer occupies.  
";

%feature("docstring") lal::numeric::integer::get_raw_value "

Returns the underlying gmp data structure.  
";

%feature("docstring") lal::numeric::integer::to_int "

Converts this integer to a signed 64-bit integer.  
";

%feature("docstring") lal::numeric::integer::to_uint "

Converts this integer to an unsigned 64-bit integer.  
";

%feature("docstring") lal::numeric::integer::to_double "

Converts this integer to a double-precision floating-point value.  
";

%feature("docstring") lal::numeric::integer::to_string "

Converts this integer to a string.  
";

%feature("docstring") lal::numeric::integer::as_string "

Converts this integer to a string.  

Parameters
----------
* `s` :  
    A reference to a string.  
";

%feature("docstring") lal::numeric::integer::swap "

Swaps the value of this integer with integer *i's* value.  

*   If none of the integers is initialised, it does nothing.  
*   If only one of the integers is initialised, moves the contents of the
    initialised integer to the other. At the end, one of the two integers is
    left uninitiliased.  
*   If both integers are initialised, swaps the values they contain.  

Parameters
----------
* `i` :  
    A lal::numeric::integer  
";

// File: structlal_1_1internal_1_1is__pointer__iterator.xml


%feature("docstring") lal::internal::is_pointer_iterator "

Attributes
----------
* `value` : `constexpr bool`  
";

// File: structlal_1_1internal_1_1memory__counting__sort.xml


%feature("docstring") lal::internal::memory_counting_sort "

Attributes
----------
* `count` : `data_array< std::size_t >`  

* `output` : `data_array< T >`  
";

%feature("docstring") lal::internal::memory_counting_sort::memory_counting_sort "
";

%feature("docstring") lal::internal::memory_counting_sort::~memory_counting_sort "
";

%feature("docstring") lal::internal::memory_counting_sort::reset_count "
";

// File: classlal_1_1iterators_1_1Q__iterator.xml


%feature("docstring") lal::iterators::Q_iterator "

Iterator over the set :math:`Q` of a graph.  

This class is used to easily iterate over the elements of the set :math:`Q` of a
graph.  

This class iterates over the independent pairs of edges of a graph. For
undirected graphs, the edges of the pair returned are edges :math:`(u,v)` so that the
inequality :math:`u < v` always holds. For directed graphs, this is not always true,
since the edges returned always has left-to-right direction.  

Bear in mind, however, that this class does not modify in any way the graph it
is initialised with.  

The correct usage of this class is  

C++ includes: Q_iterator.hpp
";

%feature("docstring") lal::iterators::Q_iterator::Q_iterator "

Constructor.  

Parameters
----------
* `g` :  
    Constant reference to the graph over which we iterate.  
";

%feature("docstring") lal::iterators::Q_iterator::~Q_iterator "

Default destructor.  
";

%feature("docstring") lal::iterators::Q_iterator::has_next "

Returns true if there are pairs of independent edges left to be iterated over.  
";

%feature("docstring") lal::iterators::Q_iterator::get_pair "

Returns the current edge pair.  
";

%feature("docstring") lal::iterators::Q_iterator::next "

Moves the iterator to the next pair, if there is any.  
";

%feature("docstring") lal::iterators::Q_iterator::reset "

Sets the iterator at the beginning of the set of edges.  

post: The next call to method next() returns the first edge of the graph.  
";

// File: classlal_1_1generate_1_1rand__lab__free__trees.xml


%feature("docstring") lal::generate::rand_lab_free_trees "
`rand_lab_free_trees(n, seed=0)`  
`rand_lab_free_trees(Gen)`  

Random labelled free tree generator.  

This is a wrapper class of __rand_lab_free_trees. Users should refrain from
using said class. However, you will find the implementation details (as for
algorithms and citations) in the documentation of said class.  

The correct usage of this class is  

Constructors
------------
* `rand_lab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled free tree generator.  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: rand_lab_free_trees.hpp
";

%feature("docstring") lal::generate::rand_lab_free_trees::rand_lab_free_trees "

Overloaded function
-------------------
* `rand_lab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_lab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled free tree generator.  
";

%feature("docstring") lal::generate::rand_lab_free_trees::~rand_lab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::rand_lab_free_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1rand__lab__rooted__trees.xml


%feature("docstring") lal::generate::rand_lab_rooted_trees "
`rand_lab_rooted_trees(n, seed=0)`  
`rand_lab_rooted_trees(Gen)`  

Random labelled rooted tree generator.  

This is a wrapper class of __rand_lab_rooted_trees. Users should refrain from
using said class. However, you will find the implementation details (as for
algorithms and citations) in the documentation of said class.  

The correct usage of this class is  

Constructors
------------
* `rand_lab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled rooted tree generator.  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: rand_lab_rooted_trees.hpp
";

%feature("docstring") lal::generate::rand_lab_rooted_trees::rand_lab_rooted_trees "

Overloaded function
-------------------
* `rand_lab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_lab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random labelled rooted tree generator.  
";

%feature("docstring") lal::generate::rand_lab_rooted_trees::~rand_lab_rooted_trees "

Default destructor.  
";

%feature("docstring") lal::generate::rand_lab_rooted_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1rand__projective__arrangements.xml


%feature("docstring") lal::generate::rand_projective_arrangements "
`rand_projective_arrangements(rT, seed=0)`  
`rand_projective_arrangements(Gen)`  

Class to generate uniformly random projective arrangements of a rooted tree.  

A projective arrangement of a directed rooted tree is one in which the root is
not covered by any of the tree's edges and there are no edge crossings.  

  

Constructors
------------
* `rand_projective_arrangements(rT, seed=0)`  
    
    Constructor with tree.  

    Parameters:
  
    * `rT` :  
        Rooted tree  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

    pre: The object *t* must be a rooted tree (see
        graphs::rooted_tree::is_rooted_tree).  

* `rand_projective_arrangements(Gen)`  
    
    Default copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random projective arrangement generator.  

C++ includes: rand_projective_arrangements.hpp
";

%feature("docstring") lal::generate::rand_projective_arrangements::rand_projective_arrangements "

Overloaded function
-------------------
* `rand_projective_arrangements(rT, seed=0)`  
    
    Constructor with tree.  

    Parameters:
  
    * `rT` :  
        Rooted tree  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

    pre: The object *t* must be a rooted tree (see
        graphs::rooted_tree::is_rooted_tree).  

* `rand_projective_arrangements(Gen)`  
    
    Default copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random projective arrangement generator.  
";

%feature("docstring") lal::generate::rand_projective_arrangements::~rand_projective_arrangements "

Default destructor.  
";

%feature("docstring") lal::generate::rand_projective_arrangements::make_rand_arrgmnt "

Make a random projective arrangement of a rooted tree.  

Returns
-------
A projective arrangement chosen uniformly at random chosen amongst all
projective arrangements of *t*.  
";

// File: classlal_1_1generate_1_1rand__ulab__free__trees.xml


%feature("docstring") lal::generate::rand_ulab_free_trees "
`rand_ulab_free_trees(n, seed=0)`  
`rand_ulab_free_trees(Gen)`  

Random unlabelled free tree generator.  

This is a wrapper class of __rand_ulab_free_trees. Users should refrain from
using said class. However, you will find the implementation details (as for
algorithms and citations) in the documentation of said class.  

The correct usage of this class is  

Constructors
------------
* `rand_ulab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled free tree generator.  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: rand_ulab_free_trees.hpp
";

%feature("docstring") lal::generate::rand_ulab_free_trees::rand_ulab_free_trees "

Overloaded function
-------------------
* `rand_ulab_free_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator. If the seed is 0 then a random
        seed is generated and used.  

* `rand_ulab_free_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled free tree generator.  
";

%feature("docstring") lal::generate::rand_ulab_free_trees::~rand_ulab_free_trees "

Default destructor.  
";

%feature("docstring") lal::generate::rand_ulab_free_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1generate_1_1rand__ulab__rooted__trees.xml


%feature("docstring") lal::generate::rand_ulab_rooted_trees "
`rand_ulab_rooted_trees(n, seed=0)`  
`rand_ulab_rooted_trees(Gen)`  

Random unlabelled rooted tree generator.  

This is a wrapper class of __rand_ulab_rooted_trees. Users should refrain from
using said class. However, you will find the implementation details (as for
algorithms and citations) in the documentation of said class.  

The correct usage of this class is  

Constructors
------------
* `rand_ulab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `rand_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled rooted tree generator.  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: rand_ulab_rooted_trees.hpp
";

%feature("docstring") lal::generate::rand_ulab_rooted_trees::rand_ulab_rooted_trees "

Overloaded function
-------------------
* `rand_ulab_rooted_trees(n, seed=0)`  
    
    Constructor with size of tree and seed for the random number generator.  

    In case the seed given is '0', a random seed will be generated.  

    Parameters:
  
    * `n` :  
        Number of nodes.  
    * `seed` :  
        The seed used for the random generator.  

* `rand_ulab_rooted_trees(Gen)`  
    
    Copy constructor.  

    Parameters:
  
    * `Gen` :  
        Random unlabelled rooted tree generator.  
";

%feature("docstring") lal::generate::rand_ulab_rooted_trees::~rand_ulab_rooted_trees "

Default destructor.  
";

%feature("docstring") lal::generate::rand_ulab_rooted_trees::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: classlal_1_1numeric_1_1rational.xml


%feature("docstring") lal::numeric::rational "
`rational()`  
`rational(n, d=1)`  
`rational(n, d=1)`  
`rational(s)`  
`rational(r)`  

Exact rational number.  

This class wraps the *mpq_t* data structure from GMP with operators for an easy
usage.  

Constructors
------------
* `rational()`  
    
    Empty constructor.  

* `rational(n, d=1)`  
    
    Constructor with numerator and denominator.  

    Parameters:
  
    * `n` :  
        Numerator, signed integer (basic type).  
    * `d` :  
        Denominator, unsigned integer (basic type).  

* `rational(n, d=1)`  
    
    Constructor with numerator and denominator.  

    Parameters:
  
    * `n` :  
        Numerator, a lal::numeric::integer.  
    * `d` :  
        Denominator, a lal::numeric::integer.  

* `rational(s)`  
    
    Constructor with string.  

    Parameters:
  
    * `s` :  
        A string.  

* `rational(r)`  
    
    Copy constructor.  

    Parameters:
  
    * `r` :  
        A lal::numeric::rational.  

C++ includes: rational.hpp
";

%feature("docstring") lal::numeric::rational::rational "

Overloaded function
-------------------
* `rational()`  
    
    Empty constructor.  

* `rational(n, d=1)`  
    
    Constructor with numerator and denominator.  

    Parameters:
  
    * `n` :  
        Numerator, signed integer (basic type).  
    * `d` :  
        Denominator, unsigned integer (basic type).  

* `rational(n, d=1)`  
    
    Constructor with numerator and denominator.  

    Parameters:
  
    * `n` :  
        Numerator, a lal::numeric::integer.  
    * `d` :  
        Denominator, a lal::numeric::integer.  

* `rational(s)`  
    
    Constructor with string.  

    Parameters:
  
    * `s` :  
        A string.  

* `rational(r)`  
    
    Copy constructor.  

    Parameters:
  
    * `r` :  
        A lal::numeric::rational.  
";

%feature("docstring") lal::numeric::rational::~rational "

Destructor.  
";

%feature("docstring") lal::numeric::rational::set_si "

Overwrites the value of this rational with :math:`n/d`   

Parameters
----------
* `n` :  
    Numerator, signed integer (basic type).  
* `d` :  
    Denominator, unsigned integer (basic type).  
";

%feature("docstring") lal::numeric::rational::set_ui "

Overwrites the value of this rational with :math:`n/d`   

Parameters
----------
* `n` :  
    Numerator, unsigned integer (basic type).  
* `d` :  
    Denominator, unsigned integer (basic type).  
";

%feature("docstring") lal::numeric::rational::set_str "

Overwrites the value in the string *s*.  

Parameters
----------
* `s` :  
    A string.  
";

%feature("docstring") lal::numeric::rational::set_integer "

Overwrites the value of this rational with the value :math:`n/d`   

Parameters
----------
* `n` :  
    Numerator, a lal::numeric::integer.  
* `d` :  
    Denominator, a lal::numeric::integer.  
";

%feature("docstring") lal::numeric::rational::set_rational "

Overwrites the value of this rational with the value :math:`n/d`   

Parameters
----------
* `r` :  
    A lal::numeric::rational.  
";

%feature("docstring") lal::numeric::rational::invert "

Changes numerator and denominator.  

If this rational value was :math:`n/d` then after calling this method it will be
:math:`d/n`   
";

%feature("docstring") lal::numeric::rational::is_initialized "

Returns whether this object is initialised or not.  
";

%feature("docstring") lal::numeric::rational::get_sign "

Returns the sign of this rational.  
";

%feature("docstring") lal::numeric::rational::bytes "

Returns the amount of bytes this integer occupies.  
";

%feature("docstring") lal::numeric::rational::to_integer "

Converts this rational to an integer value.  

This function returns :math:`\\left\\lfloor n/d \\right\\rfloor` where :math:`n,d` are,
respectively, the numerator and denominator.  

Returns
-------
The floor of this rational.  
";

%feature("docstring") lal::numeric::rational::as_integer "

Converts this rational to an integer value.  

This function returns :math:`\\left\\lfloor n/d \\right\\rfloor` where :math:`n,d` are,
respectively, the numerator and denominator.  

Returns
-------
The floor of this rational.  
";

%feature("docstring") lal::numeric::rational::to_double "

Converts this rational to a double-precision floating-point value.  
";

%feature("docstring") lal::numeric::rational::as_double "

Converts this rational to a double-precision floating-point value.  
";

%feature("docstring") lal::numeric::rational::to_string "

Converts this integer to a string.  
";

%feature("docstring") lal::numeric::rational::as_string "

Converts this integer to a string.  
";

%feature("docstring") lal::numeric::rational::swap "

Swaps the value of this rational with rational *r's* value.  

*   If none of the rationals is initialised, it does nothing.  
*   If only one of the rationals is initialised, moves the contents of the
    initialised rational to the other. At the end, one of the two rationals is
    left uninitiliased.  
*   If both rationals are initialised, swaps the values they contain.  
";

// File: classlal_1_1graphs_1_1rooted__tree.xml


%feature("docstring") lal::graphs::rooted_tree "
`rooted_tree()`  
`rooted_tree(n)`  
`rooted_tree(r)`  
`rooted_tree(t, r)`  

Rooted tree graph class.  

This class provides its users with an abstraction of rooted trees. Rooted trees
are free trees in which one vertex has been designated as the root. Furthermore,
in the context of this library, these trees' edges are always oriented towards
the leaves (away from the root); this is known as an arborescence. Many methods
require objects of this class to be valid rooted trees: the object must be a
tree (see is_tree), must have a root (see has_root), and be a valid rooted tree
(be an arborescence, that is, see is_orientation_valid).  

Rooted trees can be constructed in two different ways:  

*   Using an already-constructed free tree via a class constructor, where users
    have to indicate the root (see rooted_tree(const free_tree&, node)).
    Alternatively, one can use the method init_rooted, which has the same set of
    parameters.  
*   Adding edge after edge. In this class, as in free_tree, this addition is
    constrained so that the underlying undirected graph does not contain cycles.
    Before (or after) the addition of all the edges, it is recommended the root
    be set using set_root. If the edges have been added in a systematic fashion
    -- so it is known whether the tree is an arborescence or not --, it is
    recommended that the validity of the edges' orientation be set by the user
    via method set_valid_orientation. If it is not known (or it can't be
    guaranteed) that the resulting tree is an arborescence, use method
    find_edge_orientation.  

Adding edges one by one has a serious drawback. In case the edges do not have a
consistent orientation (either always pointing away from the root or always
pointing towards it), the resulting graph is not considered to be a valid rooted
tree (see is_rooted_tree). Due to efficiency reasons, orientation of edges is
not checked before or after their addition. Recall that removal of edges is
allowed at every moment.  

The root allows defining further properties on these graphs. For example, the
user can query information regarding subtrees of a particular rooted tree (see
methods n_nodes_subtree, calculate_size_subtrees, get_edges_subtree, and
get_subtree).  

This class allows flexibility of use of rooted trees regarding the root's
choice. Method set_root allows changing the root of rooted trees multiple times
and at any time. However, any information dependent on the root becomes invalid
upon any change of the root. This information includes, and may not be limited
to, the type of rooted tree and the size of the subtrees (see n_nodes_subtree).
For this reason, is is strongly recommended to build a free tree first and use
the constructor rooted_tree(const free_tree&, node), or the method init_rooted,
in order to build rooted trees.  

Constructors
------------
* `rooted_tree()`  
    
    Empty constructor.  

* `rooted_tree(n)`  
    
    Constructor with number of nodes and root node.  

    Parameters:
  
    * `n` :  
        Number of vertices.  

* `rooted_tree(r)`  
    
    Copy constructor.  

    Parameters:
  
    * `r` :  
        Rooted tree.  

* `rooted_tree(t, r)`  
    
    Constructor with tree and root node.  

C++ includes: rooted_tree.hpp
";

%feature("docstring") lal::graphs::rooted_tree::rooted_tree "

Overloaded function
-------------------
* `rooted_tree()`  
    
    Empty constructor.  

* `rooted_tree(n)`  
    
    Constructor with number of nodes and root node.  

    Parameters:
  
    * `n` :  
        Number of vertices.  

* `rooted_tree(r)`  
    
    Copy constructor.  

    Parameters:
  
    * `r` :  
        Rooted tree.  

* `rooted_tree(t, r)`  
    
    Constructor with tree and root node.  
";

%feature("docstring") lal::graphs::rooted_tree::~rooted_tree "

Destructor.  
";

%feature("docstring") lal::graphs::rooted_tree::add_edge "

Adds an edge to the tree.  

This operation checks that the edge added does not produce cycles only in a
*debug* compilation of the library. For a more controlled addition of the edges,
see can_add_edge.  

For developers: method graph::extra_work_per_edge_add is called after the edge
has been added.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Should the graph be normalised?  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: :math:`s \\neq t`  

pre: Edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::rooted_tree::add_edge_bulk "

Adds an edge to the graph.  

This method only adds an edge, and does no other work: normalisation is not
checked, and no extra work per edge is done.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   

pre: :math:`u \\neq v`   

pre: The edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::rooted_tree::finish_bulk_add "

Finishes adding edges in bulk.  

Parameters
----------
* `norm` :  
    Normalise the tree.  
* `check` :  
    Check whether the tree is normalised or not.  

pre: All edges have been added.  
";

%feature("docstring") lal::graphs::rooted_tree::add_edges "

Adds a list of edges to the graph.  

This function checks that edges will not produce cycles only in a *debug*
compilation of the library. Moreover, this operation is faster than calling
add_edge since the edges are added in bulk. For a more controlled addition of
the edges, see can_add_edges.  

For developers: method graph::extra_work_per_edge_add is called after each edge
has been added.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method add_edge.  

pre: None of the subsets of the list of edges can produce cycles when added.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edges.  
";

%feature("docstring") lal::graphs::rooted_tree::set_edges "

Adds a list of edges to the graph.  

This list of edges is assumed to be all the edges that are going to be added to
this graph. This means that the internal data structures are constructed more
efficiently than when adding edges one by one (see add_edge) or in several
chunks (see add_edges). For a more controlled addition of the edges, see
can_add_edges.  

Moreover, the current structure of the graph is cleared before setting the new
edges.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: There are no repeated edges in the list.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::rooted_tree::remove_edge "

Remove an edge from this graph.  

For developers: method graph::extra_work_per_edge_remove is called after the
edge has been removed.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: The edge must exist.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  

post: The validity of rooted tree and the size of the subtrees are invalidated,
    i.e., methods is_orientation_valid and size_subtrees_valid return false.  
";

%feature("docstring") lal::graphs::rooted_tree::remove_edges "

Remove an edge from this graph.  

This operation is faster than removing edges one by one with
remove_edge(node,node,bool,bool) since the edges are removed in bulk.  

For developers: method graph::extra_work_per_edge_remove is called after each
edge has been removed.  

Parameters
----------
* `edges` :  
    The edges to be deleted.  
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  

post: The validity of the rooted tree and the size of the subtrees are
    invalidated, i.e., methods is_orientation_valid and size_subtrees_valid
    return false.  
";

%feature("docstring") lal::graphs::rooted_tree::disjoint_union "

Overloaded function
-------------------
* `disjoint_union(t, connect_roots=true)`  
    
    Disjoint union of trees.  

    Append a rooted tree to this tree. All the nodes in *t* are relabelled
    starting at *n*, the number of nodes of the current tree. If the current
    graph has no vertices, then the contents of *t* are simply copied into this
    graph.  

    Parameters:
  
    * `t` :  
        Input tree.  
    * `connect_roots` :  
        The root of the current tree and the root of *t* are joined by an edge.  

    pre: If *connect_roots* is true then both trees need to have a root (see
        method has_root).  

    post: The root (if set) of the current tree is kept.  

    post: Copying the edges of *t* into this tree retains their original
        orientation.  

    post: The size of the subtrees might need recalculating:  

        *   If method size_subtrees_valid() returns true for both trees then the
            subtree sizes are updated and do not need to be recalculated and
            method size_subtrees_valid() still returns true.  
        *   If for one of the tw graphs method size_subtrees_valid() returns
            false then it will still return false after this operation.  

    post: The graph resulting from the union is normalised only if the two
        graphs were normalised prior to the union.  

* `disjoint_union(g)`  
    
    Disjoint union of graphs.  

    Given a graph, append it to the current graph.  

    All the nodes in *g* are relabelled starting at *n*, the number of nodes of
    the current graph.  

    Parameters:
  
    * `g` :  
        Input graph.  

    post: The graph is normalised only if it was normalised before the call and
        *g* is also normalised.  
";

%feature("docstring") lal::graphs::rooted_tree::find_edge_orientation "

Finds the orientation of the edges.  

It is mandatory that this tree be an arborescence. Therefore, when the tree has
been built by adding edges (see add_edge, add_edges), the user must tell this
class whether what has been built is an arborescence or not. One can do this by
calling method find_edge_orientation or by setting the type directly using
method set_valid_orientation.  

This method examines the orientation of the tree's edges with respect to the
root and to the leaves, i.e., it determines whether all edges are oriented
towards the leaves (away from the root).  

Returns
-------
True if the tree is an arborescence. Returns false otherwise.  

pre: This object is a tree (see is_tree).  

pre: This tree has a root (see has_root).  

post: Method is_orientation_valid evaluates to true if the tree is an
    arborescence, or to false if it not an arborescence.  
";

%feature("docstring") lal::graphs::rooted_tree::set_valid_orientation "

Sets wether the type of the rooted tree is valid or not.  

It is mandatory that this tree be an arborescence. Therefore, when the tree has
been built by adding edges (see add_edge, add_edges), the user must tell this
class whether what has been built is an arborescence or not. One can do this by
calling method find_edge_orientation or by setting the type directly using
method set_valid_orientation.  

Parameters
----------
* `valid` :  
    Boolean value telling whether the tree is valid or not.  

post: Method is_orientation_valid returns the value set by this function.  
";

%feature("docstring") lal::graphs::rooted_tree::init_rooted "

Initialiser with tree and root node.  

Constructs a rooted tree from a free tree and one of its nodes as the root of
the rooted tree.  

Since the edges are oriented, method is_tree must be true on parameter *t*
(otherwise, some edges might not be reachable from the root and hence completely
undirectable).  

Parameters
----------
* `t` :  
    Undirected tree.  
* `r` :  
    Root of the directed tree. A node of *g*.  

pre: Parameter *t* must be a tree (see is_tree).  

post: Method is_rooted_tree returns true.  
";

%feature("docstring") lal::graphs::rooted_tree::calculate_size_subtrees "

Calculates the number of nodes at every rooted subtree.  

pre: The object must be a tree (see is_tree()).  

pre: The tree must have a root (see has_root()).  

post: Method size_subtrees_valid returns true.  
";

%feature("docstring") lal::graphs::rooted_tree::calculate_tree_type "

Calculates the type of tree.  

See tree_type for the list of different tree types.  
";

%feature("docstring") lal::graphs::rooted_tree::set_root "

Set the root of this tree.  

Changing the root of a rooted tree invalidates information dependant on the
tree. See the postconditions for details.  

Parameters
----------
* `r` :  
    Vertex that represents the root.  

post: Method has_root returns true.  

post: The type of rooted tree and the size of the subtrees are invalidated.  
";

%feature("docstring") lal::graphs::rooted_tree::is_rooted "

Returns whether this tree is a rooted tree.  
";

%feature("docstring") lal::graphs::rooted_tree::is_rooted_tree "

Is this tree a valid rooted tree?  

A tree is a valid rooted tree when:  

*   the underlying undirected graph is connected and does not contain cycles
    (see is_tree()),  
*   the tree has a root (see has_root, set_root, get_root),  
*   the orientation of the edges is valid (see is_orientation_valid).  

    Returns:
    Whether this tree is a valid rooted tree or not.  
";

%feature("docstring") lal::graphs::rooted_tree::is_orientation_valid "

Is the orientation of the edges valid?  

The edges' orientation is valid if they are all oriented towards the leaves
(away from the root).  

This function returns the value of private attribute m_valid_orientation.  

Returns
-------
The whether the orientation is valid or not.  
";

%feature("docstring") lal::graphs::rooted_tree::get_root "

Return the root of this tree.  
";

%feature("docstring") lal::graphs::rooted_tree::has_root "

Returns whether this rooted tree's root has been set or not (see set_root).  
";

%feature("docstring") lal::graphs::rooted_tree::n_nodes_subtree "

Get the size of a subtree rooted at a given node.  

Parameters
----------
* `u` :  
    Vertex of the tree.  

Returns
-------
The number of nodes of the subtree rooted at *u*.  

pre: Method size_subtrees_valid returns true.  
";

%feature("docstring") lal::graphs::rooted_tree::size_subtrees_valid "

Is a recalculation of the subtree's sizes needed?  

If the method returns *false* then the user should call calculate_size_subtrees
so that the size of every rooted subtree is recalculated. This information must
be calculated prior to calling many functions of this library.  

Returns
-------
Whether m_size_subtrees should be recalculated or not.  
";

%feature("docstring") lal::graphs::rooted_tree::get_edges_subtree "

Retrieve the edges of the subtree rooted at *u*.  

The list of edges returned contains labels that depend on the parameter *relab*.
If *relab* is true then the nodes are relabelled to numbers in :math:`[0, n_u)`  where
:math:`n_u` is the number of nodes of the subtree rooted at *u*, rather than keeping
the original labelling of numbers in :math:`[0,n)`  where *n* is the number of nodes
of the tree.  

In case of directed trees, the subtree is extracted regardless of the
orientation of the edges. For example, consider the following complete binary
tree of 7 nodes, whose edges are
0 -> 1 -> 3
       -> 4
  -> 2 -> 5
       -> 6
 The edges of the subtree rooted at 1 are \"1 -> 3\" and \"1 -> 4\". Moreover,
the orientation of the edges in the new tree is kept.  

This method can be seen as a way of relabelling nodes when *u* is the root of
the tree and *relab* is true.  

Parameters
----------
* `u` :  
    Root node of the subtree.  
* `relab` :  
    Should the nodes be relabelled?  

Returns
-------
A list of edges.  

pre: The object must be a valid rooted tree (see is_rooted_tree).  

post: Whenever *relab* is true, the label of the first node of the first edge is
    guaranteed to be node '0'.  
";

%feature("docstring") lal::graphs::rooted_tree::get_subtree "

Retrieve the subtree rooted at node *u*.  

Parameters
----------
* `u` :  
    Root of the subtree.  

Returns
-------
A tree containing the nodes of the subtree rooted at node *u*.  

pre: The object must be a valid rooted tree (see is_rooted_tree).  

post: The subtree keeps the orientation of the edges in the original tree.  
";

%feature("docstring") lal::graphs::rooted_tree::to_undirected "

Converts this rooted tree into a free tree (see tree).  

Parameters
----------
* `norm` :  
    Normalise the tree.  
* `check` :  
    Chech whether the resulting graph is normalised or not.  
";

%feature("docstring") lal::graphs::rooted_tree::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::rooted_tree::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::rooted_tree::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::rooted_tree::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::rooted_tree::has_edge "

Returns true if the edge :math:`(u,v)` exists in the graph.  
";

%feature("docstring") lal::graphs::rooted_tree::get_out_neighbours "

Returns the out-neighbours of node *u*.  

Parameters
----------
* `u` :  
    Node  

Returns
-------
The list of nodes leaving node *u*.  
";

%feature("docstring") lal::graphs::rooted_tree::get_in_neighbours "

Returns the in-neighbours of node *u*.  

Parameters
----------
* `u` :  
    Node  

Returns
-------
The list of nodes entering at node *u*.  
";

%feature("docstring") lal::graphs::rooted_tree::degree "

Returns the in-degree plus the out-degree of this vertex.  

Returns the degree of this vertex in its underlying undirected structure. Same
as in_degree + out_degree.  

Parameters
----------
* `u` :  
    Vertex  

Returns
-------
The (in + out) degree of this vertex.  
";

%feature("docstring") lal::graphs::rooted_tree::out_degree "

Returns the out-degree of a node.  
";

%feature("docstring") lal::graphs::rooted_tree::in_degree "

Returns the in-degree of a node.  
";

%feature("docstring") lal::graphs::rooted_tree::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::rooted_tree::is_undirected "

Returns whether this graph is undirected or not.  
";

%feature("docstring") lal::graphs::rooted_tree::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::rooted_tree::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::rooted_tree::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::rooted_tree::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::rooted_tree::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::rooted_tree::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::rooted_tree::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

%feature("docstring") lal::graphs::rooted_tree::is_tree "

Returns whether this graph is an actual tree or not.  

Returns true if the number of edges is one less than the number of nodes. Note
that this would not really be true if the addition of edges was not constrained.
Since it is constrained in a way that no cycles can be produced (for example,
see free_tree::add_edge, or free_tree::add_edges), then we only need to check
for the number of edges.  

For further characterisations of a tree see [13] (chapter 4, pages 32-33).  
";

%feature("docstring") lal::graphs::rooted_tree::can_add_edge "

Can this edge be added?  

In a tree, an edge can only be added if it does not produce cycles, and it has
not been added before.  

Parameters
----------
* `s` :  
    First node of the edge.  
* `t` :  
    Second node of the edge.  

Returns
-------
Whether the addition of this new edge can be added to the tree without producing
cycles.  
";

%feature("docstring") lal::graphs::rooted_tree::can_add_edges "

Can these edges be added?  

In a tree, a set of edges can only be added if their addition to the tree do not
produce cycles and none of them have been added before.  

Parameters
----------
* `edges` :  
    List of edges.  

Returns
-------
Whether the addition of these new edges can be added to the tree without
producing cycles.  
";

%feature("docstring") lal::graphs::rooted_tree::num_nodes_component "

Amount of nodes in a connected component of the tree.  

When tree has had an edge removed, or when it is not completely built, i.e., it
lack some edges, the resulting graph is clearly a forest. This function returns
the size of the forest node *u* belongs to.  

In directed trees one has to see this amount as the number of nodes of the
component in the undirected version of the forest.  

Parameters
----------
* `u` :  
    Input node.  

Returns
-------
The size of the connected component of *u*.  
";

%feature("docstring") lal::graphs::rooted_tree::is_of_type "

Returns whether this tree is of type *tt*.  
";

%feature("docstring") lal::graphs::rooted_tree::get_tree_type_list "

Returns the list of types as a list of strings.  

Returns
-------
The list of types as a list of strings.  
";

// File: classlal_1_1sorted__vector.xml


%feature("docstring") lal::sorted_vector "
";

%feature("docstring") lal::sorted_vector::sorted_vector "

Overloaded function
-------------------
* `sorted_vector()`  

* `sorted_vector(n)`  

* `sorted_vector(n, x)`  

* `sorted_vector(v)`  

* `sorted_vector(v)`  
";

%feature("docstring") lal::sorted_vector::~sorted_vector "
";

%feature("docstring") lal::sorted_vector::insert_sorted "

Overloaded function
-------------------
* `insert_sorted(x)`  

* `insert_sorted(x)`  
";

%feature("docstring") lal::sorted_vector::insert_sorted_unique "

Overloaded function
-------------------
* `insert_sorted_unique(x)`  

* `insert_sorted_unique(x)`  
";

%feature("docstring") lal::sorted_vector::remove_sorted "
";

%feature("docstring") lal::sorted_vector::contains "
";

%feature("docstring") lal::sorted_vector::find_sorted "
";

// File: classlal_1_1graphs_1_1tree.xml


%feature("docstring") lal::graphs::tree "
`tree()`  
`tree(t)`  

Tree graph class.  

This is an abstract class for those tree-like graphs. Classes that implement
different abstractions of trees and that inherit from this class are: free_tree,
rooted_tree.  

In these classes the addition of edges is constrained so as to ensure that the
edges added actually yield trees, i.e., that cycles are never produced. For the
sake of efficiency, only debug compilations of the library (compilations where
the DEBUG symbol is defined) check that such additions do not produce cycles. In
case of doubt, one can query the class using methods can_add_edge or
can_add_edges prior to adding one or several edges.  

Constructors
------------
* `tree()`  
    
    Empty constructor.  

* `tree(t)`  
    
    Copy constructor.  

    Parameters:
  
    * `t` :  
        Tree.  

C++ includes: tree.hpp
";

%feature("docstring") lal::graphs::tree::tree "

Overloaded function
-------------------
* `tree()`  
    
    Empty constructor.  

* `tree(t)`  
    
    Copy constructor.  

    Parameters:
  
    * `t` :  
        Tree.  
";

%feature("docstring") lal::graphs::tree::~tree "

Destructor.  
";

%feature("docstring") lal::graphs::tree::calculate_tree_type "

Calculates the type of tree.  

See tree_type for the list of different tree types.  
";

%feature("docstring") lal::graphs::tree::is_tree "

Returns whether this graph is an actual tree or not.  

Returns true if the number of edges is one less than the number of nodes. Note
that this would not really be true if the addition of edges was not constrained.
Since it is constrained in a way that no cycles can be produced (for example,
see free_tree::add_edge, or free_tree::add_edges), then we only need to check
for the number of edges.  

For further characterisations of a tree see [13] (chapter 4, pages 32-33).  
";

%feature("docstring") lal::graphs::tree::is_rooted "

Returns whether this tree is a rooted tree.  
";

%feature("docstring") lal::graphs::tree::can_add_edge "

Can this edge be added?  

In a tree, an edge can only be added if it does not produce cycles, and it has
not been added before.  

Parameters
----------
* `s` :  
    First node of the edge.  
* `t` :  
    Second node of the edge.  

Returns
-------
Whether the addition of this new edge can be added to the tree without producing
cycles.  
";

%feature("docstring") lal::graphs::tree::can_add_edges "

Can these edges be added?  

In a tree, a set of edges can only be added if their addition to the tree do not
produce cycles and none of them have been added before.  

Parameters
----------
* `edges` :  
    List of edges.  

Returns
-------
Whether the addition of these new edges can be added to the tree without
producing cycles.  
";

%feature("docstring") lal::graphs::tree::num_nodes_component "

Amount of nodes in a connected component of the tree.  

When tree has had an edge removed, or when it is not completely built, i.e., it
lack some edges, the resulting graph is clearly a forest. This function returns
the size of the forest node *u* belongs to.  

In directed trees one has to see this amount as the number of nodes of the
component in the undirected version of the forest.  

Parameters
----------
* `u` :  
    Input node.  

Returns
-------
The size of the connected component of *u*.  
";

%feature("docstring") lal::graphs::tree::is_of_type "

Returns whether this tree is of type *tt*.  
";

%feature("docstring") lal::graphs::tree::get_tree_type_list "

Returns the list of types as a list of strings.  

Returns
-------
The list of types as a list of strings.  
";

%feature("docstring") lal::graphs::tree::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::tree::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::tree::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::tree::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::tree::finish_bulk_add "

Completes the inner structure of the graph after adding a bulk of edges.  

This is meant to be used after several calls to undirected_graph::add_edge_bulk,
directed_graph::add_edge_bulk.  

Parameters
----------
* `norm` :  
    Normalise the graph  
* `check` :  
    Check wether the graph is normalised or not.  
";

%feature("docstring") lal::graphs::tree::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::tree::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::tree::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::tree::has_edge "

Returns true if the undirected edge (*u*, *v*) exists in the graph.  
";

%feature("docstring") lal::graphs::tree::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::tree::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::tree::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::tree::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

%feature("docstring") lal::graphs::tree::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::tree::is_undirected "

Returns whether this graph is undirected or not.  
";

// File: classlal_1_1generate_1_1tree__gen.xml


%feature("docstring") lal::generate::tree_gen "

Base class for tree generators.  

This class is simply a helper for preprocessing a generated tree. The
preprocessing applied to the tree depends on whether said tree is a rooted tree
or a free tree.  

In the following list you will find all the attributes that govern the
preprocessing. Those marked with an 'r', are only for rooted trees; those marked
with an 'f' are only for free trees. When marked with both, the preprocessing is
applied to both types trees. The list of said attributes is:  

*   normalise_tree (rf)  
*   calculate_size_subtrees (r)  
*   calculate_tree_type (rf)  

Parameters
----------
* `T` :  
    Type of tree.  
* `is_free` :  
    This tells whether the type corresponds to a free tree or not.  

Attributes
----------
* `normalise_tree` : `bool`  
    Normalise the generate tree.  

* `calculate_size_subtrees` : `bool`  
    Calculate the size of the subtrees of the generated rooted tree.  

* `calculate_tree_type` : `bool`  
    Calculate the type of tree of the generated tree.  

C++ includes: tree_gen.hpp
";

%feature("docstring") lal::generate::tree_gen::tree_gen "

Overloaded function
-------------------
* `tree_gen(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes  

* `tree_gen(Gen)`  
    
    Default copy constructor.  

    Parameters:
  
    * `Gen` :  
        Generator of the same type.  
";

%feature("docstring") lal::generate::tree_gen::~tree_gen "

Default destructor.  
";

%feature("docstring") lal::generate::tree_gen::get_tree "

Retrieve the generated tree.  

This function first calls __get_tree and then modifies the generated tree
according to the values:  

*   normalise_tree  
*   calculate_size_subtrees  
*   calculate_tree_type  
";

// File: structlal_1_1internal_1_1AVL_1_1tree__node.xml

// File: classlal_1_1io_1_1treebank__dataset__processor.xml


%feature("docstring") lal::io::treebank_dataset_processor "

Treebank dataset processor.  

This class, the objects of which will be referred to as the \"processors\", has
the goal to ease the processing a whole treebank dataset and produce data for a
fixed set of features. This is most useful when the features to be calculated
are only those available in the library. See the enumeration tree_feature for
details on the features available. Since not all features available have to be
computed, this class offers the possibility to compute only a subset of them.
Each feature can be set to be calculated via method add_feature.  

A treebank dataset is made up of a set of files, each containing several
syntactic dependency trees of sentences. Each file is referred to as a treebank
file. Each of these files is referenced within a \"main file list\", henceforth
called the \"main file\". The main file is a two-column formatted file, the
first of which contains a self-descriptive name of the treebank that is
indicated in the next column.  

For example, the main file of a treebank dataset of languages could contain:  

    arb path/to/file/ar-all.heads2
    eus path/to/file/eu-all.heads2
    ben path/to/file/bn-all.heads2
    ...
 where the first column contains a string referencing the treebank of a language
(in this case, by giving an ISO code of a language), and the second column
contains the full path to the file with the syntactic dependency trees.  

Every processor must be initialised prior to processing the files. This is done
via method init, which requires the path to the main file and the output
directory where the results are going to be stored. Besides these, it also
requires a Boolean value indicating whether all (or none) of the features should
be used. Moreover, it also admits an optional parameter indicating the number of
threads to be used to parallelise the processing of the files. Finally, the
treebank dataset is processed via method process which returns a value of the
enumeration processor_error. Further errors can be checked via methods
get_num_processor_errors, get_error_type, get_error_treebank_filename,
get_error_treebank_name.  

The usage of this class is a lot simpler than that of class
treebank_dataset_reader. See code for details.  

C++ includes: treebank_dataset_processor.hpp
";

%feature("docstring") lal::io::treebank_dataset_processor::init "

Initialise the processor with a new dataset.  

If the parameter *all_fs* is true, the list is initialised with all features
possible.  

Parameters
----------
* `file` :  
    Main file.  
* `odir` :  
    Output directory.  
* `all_fs` :  
    Should the feature list contain all possible features?  
* `n_threads` :  
    Number of threads to use in a parallel application.  
";

%feature("docstring") lal::io::treebank_dataset_processor::add_feature "

Adds a feature to the processor.  

Parameters
----------
* `fs` :  
    Feature to be added.  
";

%feature("docstring") lal::io::treebank_dataset_processor::remove_feature "

Removes a feature from the processor.  

Parameters
----------
* `fs` :  
    Feature to be removed.  
";

%feature("docstring") lal::io::treebank_dataset_processor::set_separator "

Sets the separator character.  

Default is '\\t'.  

Parameters
----------
* `c` :  
    The separator character.  
";

%feature("docstring") lal::io::treebank_dataset_processor::set_verbosity "

Sets the level of verbosity of the process method.  

Default is 0 (i.e., no verbosity at all). Verbosity is organised by levels:  

*   Level 1: outputs progress messages.  
*   Level 2: outputs error messages.  

    Parameters:
  
    * `k` :  
        Verbosity level.  
";

%feature("docstring") lal::io::treebank_dataset_processor::set_output_header "

Output a hedaer for each processed treebank file.  

Default is true.  

Parameters
----------
* `h` :  
    Output header or not.  
";

%feature("docstring") lal::io::treebank_dataset_processor::get_num_processor_errors "

Returns the number of errors that arised during processing.  
";

%feature("docstring") lal::io::treebank_dataset_processor::get_error_type "

Get the *ith* error. This is a value of the enumeration processor_error.  
";

%feature("docstring") lal::io::treebank_dataset_processor::get_error_treebank_filename "

Get the treebank's file name for which the *ith* error happened.  
";

%feature("docstring") lal::io::treebank_dataset_processor::get_error_treebank_name "

Get the treebank's name for which the *ith* error happened.  
";

%feature("docstring") lal::io::treebank_dataset_processor::process "

Process the dataset.  

This method produces the information as explained in this class' description.
However, it may fail to do so. In this case it will return a value different
from processor_error::no_error.  

This function uses attributes m_separator, m_output_header to format the output
data. It also outputs the current progress if m_be_verbose is set to true.  

Moreover, it gathers the errors thay may have occurred during processing. If so,
see methods get_num_processor_errors, get_error_type, get_error_treebank_name.  

Returns
-------
A value describing the error (if any) that occurred while processing the
dataset. If any error ocurred, see methods  
";

// File: classlal_1_1io_1_1treebank__dataset__reader.xml


%feature("docstring") lal::io::treebank_dataset_reader "

A reader for a dataset of treebank files.  

This class, the objects of which will be referred to as the \"dataset readers\",
is an interface to help you do a custom processing of a set of treebanks. A
treebank dataset is a set of files, each of which is a treebank. A treebank is a
file containing one or more lines, each describing a syntactic dependency tree.
If you want to output any of the features already calculated by the library, use
class treebank_dataset_processor instead; said class is much easier to use and
can process treebanks in parallel.  

Each tree in a treebank file is formatted as a list of whole positive numbers
(including zero), each representing a node of the tree. The number 0 denotes the
root of the tree, and a number at a certain position indicates its parent node.
For example, when number 4 is at position 9 it means that node 9 has parent node
4. Therefore, if number 0 is at position 1 it means that node 1 is the root of
the tree. A complete example of such a tree's representation is the following  

      0 3 4 1 6 3
 which should be interpreted as  

    predecessor:       0 3 4 1 6 3
    node of the tree:  1 2 3 4 5 6
 Note that lines like these are not valid:  

    (1) 0 2 2 2 2 2
    (2) 2 0 0
 Line (1) is not valid due to a self-reference in the second position, and (2)
not being valid due to containing two '0' (i.e., two roots).  

A treebank dataset reader helps you navigate through a treebank dataset. It does
the job of initialising the treebank_reader class, which is what you need to do
a custom process of a treebank file.  

Now, the treebank files are referenced within a \"main file list\", henceforth
called the main file. The main file's lines contain only two strings describing
a treebank. The first string is a self-descriptive name of the treebank (e.g.,
the ISO code of a language), and the second is the relative path to the file
containing the syntactic dependency trees (e.g., the syntactic dependency trees
of a language in a dataset). The path is relative to the directory that contains
the main file.  

For example, the main file could be called *stanford.txt*, representing the
Stanford dataset, and could contain:  

    arb path/to/file/ar-all.heads2
    eus path/to/file/eu-all.heads2
    ben path/to/file/bn-all.heads2
    ...
 where the first column contains a string referencing the language (in this
case, an ISO code), and the second column contains the relative path to the file
with the syntactic dependency trees.  

The user has to initialise a dataset reader with the main file (the main file
list). For example, to read the Stanford dataset the reader has to be
initialised with the main file *stanford.txt* which could contain the contents
given above. Bear in mind that a dataset reader only processes the main file: it
iterates through the list of files within the main file using the method
next_treebank. This method can be called as long as method has_treebank returns
true. Each call to next_treebank builds an object of class treebank_reader which
allows the user to iterate through the trees within the corresponding file. This
object can be retrieved by calling method get_treebank_reader.  

The correct usage of this class is given in the following piece of code.  

C++ includes: treebank_dataset_reader.hpp
";

%feature("docstring") lal::io::treebank_dataset_reader::init "

Initialise the reader with a new dataset.  

Parameters
----------
* `main_file` :  
    Main file of the dataset.  

Returns
-------
If any occurred then returns its type.  
";

%feature("docstring") lal::io::treebank_dataset_reader::has_treebank "

Returns whether there is a next treebank to be read.  
";

%feature("docstring") lal::io::treebank_dataset_reader::next_treebank "

Opens the file of the next treebank in the main file.  

Returns
-------
In case of error, returns a value different from dataset_error::none.  
";

%feature("docstring") lal::io::treebank_dataset_reader::get_treebank_reader "

Returns a treebank reader class instance for processing a treebank.  
";

// File: classlal_1_1io_1_1treebank__reader.xml


%feature("docstring") lal::io::treebank_reader "

A reader for a single treebank file.  

This class, the objects of which will be referred to as the \"readers\", offers
a simple interface for iterating over the trees in a single treebank file,
henceforth referred to as the treebank. Each tree is formatted as a list of
whole, positive numbers (including zero), each representing a node of the tree.
The number 0 denotes the root of the tree, and a number at a certain position
indicates its parent node. For example, when number 4 is at position 9 it means
that node 9 has parent node 4. Therefore, if number 0 is at position 1 it means
that node 1 is the root of the tree. A complete example of such a tree's
representation is the following  

      0 3 4 1 6 3
 which should be interpreted as  

    predecessor:       0 3 4 1 6 3
    node of the tree:  1 2 3 4 5 6
 Note that lines like these are not valid:  

    (1) 0 2 2 2 2 2
    (2) 2 0 0
 Line (1) is not valid due to a self-reference in the second position, and (2)
not being valid due to containing two '0' (i.e., two roots).  

In order to use it, this class has to be first initialized with the treebank
file and, optionally, a self-descriptive string, i.e., something that identifies
the treebank (e.g., an ISO code of a language). Once initialised, the user can
iterate over the trees within the file by calling next_tree. This function can
only be called as long as has_tree returns true. Retrieving the trees is done by
calling the function get_tree.  

If an object of this class was returned by the class treebank_dataset_reader,
then methods get_treebank_filename and get_identifier might prove useful for
debugging since they return, respectively, the full name (path included) of the
treebank and the language it corresponds to.  

The correct usage of this class is given in the following piece of code.  

C++ includes: treebank_reader.hpp
";

%feature("docstring") lal::io::treebank_reader::init "

Initialises the treebank reader.  

Parameters
----------
* `file` :  
    Treebank file.  
* `identifier` :  
    Identifier string for the treebank.  

Returns
-------
If any error occurred, returns its type.  

post: The amount of trees processed, m_num_trees, is always set to 0.  
";

%feature("docstring") lal::io::treebank_reader::has_tree "

Returns whether there is another tree to be processed.  
";

%feature("docstring") lal::io::treebank_reader::next_tree "

Retrieves the next tree in the file.  

Returns
-------
In case the function returns dataset_error::empty_line method get_tree should
not be called.  

post: Increments the amount of trees found.  
";

%feature("docstring") lal::io::treebank_reader::get_num_trees "

Returns the number of trees processed so far.  

When method has_tree returns 'false', this method returns the exact amount of
trees in the treebank.  
";

%feature("docstring") lal::io::treebank_reader::get_identifier "

Returns the language's name corresponding of the treebank.  
";

%feature("docstring") lal::io::treebank_reader::get_treebank_filename "

Returns the name of the treebank file.  
";

%feature("docstring") lal::io::treebank_reader::get_tree "

Returns the current tree.  
";

// File: classlal_1_1graphs_1_1undirected__graph.xml


%feature("docstring") lal::graphs::undirected_graph "
`undirected_graph()`  
`undirected_graph(n)`  
`undirected_graph(g)`  

Undirected graph class.  

Class implementing an undirected graph, using the adjacency list data structure.  

An object of this class must be initialised either with its constructor or with
the init(uint32_t) method. Edges can then be added one by one (see
add_edge(node,node,bool,bool) ) or all at the same time (see add_edges(const
std::vector<edge>&, bool, bool) ).  

Constructors
------------
* `undirected_graph()`  
    
    Empty constructor.  

* `undirected_graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `undirected_graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Undirected graph.  

C++ includes: undirected_graph.hpp
";

%feature("docstring") lal::graphs::undirected_graph::undirected_graph "

Overloaded function
-------------------
* `undirected_graph()`  
    
    Empty constructor.  

* `undirected_graph(n)`  
    
    Constructor with number of nodes.  

    Parameters:
  
    * `n` :  
        Number of nodes.  

* `undirected_graph(g)`  
    
    Copy constructor.  

    Parameters:
  
    * `g` :  
        Undirected graph.  
";

%feature("docstring") lal::graphs::undirected_graph::~undirected_graph "

Destructor.  
";

%feature("docstring") lal::graphs::undirected_graph::add_edge "

Adds an edge to the graph.  

For developers: method graph::extra_work_per_edge_add is called after the edge
has been added.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Should the graph be normalised?  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: :math:`u \\neq v`  The edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::add_edge_bulk "

Adds an edge to the graph.  

This method only adds an edge, and does no other work: normalisation is not
checked, and no extra work per edge is done.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   

pre: :math:`u \\neq v`   

pre: The edge :math:`\\{s,t\\}` is not part of the graph.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::finish_bulk_add "

Completes the inner structure of the graph after adding a bulk of edges.  

This is meant to be used after several calls to undirected_graph::add_edge_bulk,
directed_graph::add_edge_bulk.  

Parameters
----------
* `norm` :  
    Normalise the graph  
* `check` :  
    Check wether the graph is normalised or not.  
";

%feature("docstring") lal::graphs::undirected_graph::add_edges "

Adds a list of edges to the graph.  

This operation is faster than calling add_edge(node,node,bool,bool) since the
edges are added in bulk.  

For developers: method graph::extra_work_per_edge_add is called for every edge
added.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::set_edges "

Adds a list of edges to the graph.  

This list of edges is assumed to be all the edges that are going to be added to
this graph. This means that the internal data structures are constructed more
efficiently than when adding edges one by one (see add_edge) or in several
chunks (see add_edges).  

Moreover, the current structure of the graph is cleared before setting the new
edges.  

Parameters
----------
* `edges` :  
    The edges to be added.  
* `norm` :  
    Normalise the graph after the insertions.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: There are no repeated edges in the list.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::remove_edge "

Remove an edge from this graph.  

For developers: method graph::extra_work_per_edge_remove is called after the
edge has been removed.  

Parameters
----------
* `s` :  
    Valid node index: :math:`0 \\le s < n`   
* `t` :  
    Valid node index: :math:`0 \\le t < n`   
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: The edge must exist.  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::remove_edges "

Remove an edge from this graph.  

This operation is faster than removing edges one by one with
remove_edge(node,node,bool,bool) since the edges are removed in bulk.  

For developers: method graph::extra_work_per_edge_remove is called after each
edge has been removed.  

Parameters
----------
* `edges` :  
    The edges to be deleted.  
* `norm` :  
    Normalise the graph after the deletion.  
* `check_norm` :  
    If *norm* is false then, should we check whether the result is normalised or
    not? This might be useful in case the resulting graph is normalised. If
    *norm* is true then *check_norm* is ignored.  

pre: All the edges in *edges* must meet the precondition of method
    add_edge(node,node,bool,bool).  

post: If *norm* is true the graph is guaranteed to be normalised after the
    addition of the edge.  
";

%feature("docstring") lal::graphs::undirected_graph::disjoint_union "

Disjoint union of graphs.  

Given a graph, append it to the current graph.  

All the nodes in *g* are relabelled starting at *n*, the number of nodes of the
current graph.  

Parameters
----------
* `g` :  
    Input graph.  

post: The graph is normalised only if it was normalised before the call and *g*
    is also normalised.  
";

%feature("docstring") lal::graphs::undirected_graph::Q "

Returns all independent pairs of edges of this graph.  

The set :math:`Q(G)` is defined as the pairs of edges of :math:`G`  :math:`E(G) \\times E(G)` 
that are independent, that is, that share no nodes.  
";

%feature("docstring") lal::graphs::undirected_graph::edges "

Returns all edges of this graph.  
";

%feature("docstring") lal::graphs::undirected_graph::get_neighbours "

Returns the neighbourhood of node *u*.  

Parameters
----------
* `u` :  
    Node.  

Returns
-------
The list of nodes adjacent to node *u*.  
";

%feature("docstring") lal::graphs::undirected_graph::degree "

Returns the number of neighbours of *u*.  

Parameters
----------
* `u` :  
    Node to be queried.  

Returns
-------
The number of adjacent nodes.  
";

%feature("docstring") lal::graphs::undirected_graph::has_edge "

Returns true if the edge :math:`\\{u,v\\}` exists in the graph.  
";

%feature("docstring") lal::graphs::undirected_graph::is_directed "

Returns whether this graph is directed or not.  
";

%feature("docstring") lal::graphs::undirected_graph::is_undirected "

Returns whether this graph is undirected or not.  
";

%feature("docstring") lal::graphs::undirected_graph::init "

Allocates the necessary memory for this class.  

See _init for details.  

Parameters
----------
* `n` :  
    Number of nodes.  
";

%feature("docstring") lal::graphs::undirected_graph::clear "

Frees the memory occupied by this graph.  

See _clear for details.  

post: The graph is normalised. The number of edges is 0.  
";

%feature("docstring") lal::graphs::undirected_graph::normalise "

Normalises the graph.  

Sorts this graph's adjacency list structure in increasing order.  

Besides expensive, this method may be unnecessary. Method check_normalised()
checks whether the graph is normalised or not; in case it is, using this method
is completely unnecessary.  

post: Method is_normalised evaluates to true.  
";

%feature("docstring") lal::graphs::undirected_graph::check_normalised "

Checks if the graph is normalised.  

Checks, whether the graph's adjacency structure is normalised or not. In case it
is, attribute m_normalised is set to true, so method is_normalised evaluates to
true.  
";

%feature("docstring") lal::graphs::undirected_graph::set_normalised "

Sets whether this graph is normalised or not.  
";

%feature("docstring") lal::graphs::undirected_graph::has_node "

Returns true if node *u* is in this graph.  
";

%feature("docstring") lal::graphs::undirected_graph::num_nodes "

Returns the number of ndoes.  
";

%feature("docstring") lal::graphs::undirected_graph::num_edges "

Returns the number of edges.  
";

%feature("docstring") lal::graphs::undirected_graph::is_normalised "

Returns whether this graph is normalised or not.  

A graph is normalised if every node's adjacency list is sorted increasingly. For
this, use method normalise().  

Returns
-------
The value of m_normalised.  
";

// File: namespacelal.xml

// File: namespacelal_1_1generate.xml

// File: namespacelal_1_1graphs.xml

%feature("docstring") lal::graphs::tree_type_to_string "

Converts to a string a value of the enumeration tree_type.  
";

// File: namespacelal_1_1internal.xml

%feature("docstring") lal::internal::__lal::mpz_pow_mpz "
";

%feature("docstring") lal::internal::__lal::mpz_divide_mpq "
";

%feature("docstring") lal::internal::__lal::mpq_divide_mpq "
";

%feature("docstring") lal::internal::__lal::operate_power "

Overloaded function
-------------------
* `operate_power(r, p)`  

* `operate_power(r, p)`  
";

%feature("docstring") lal::internal::__lal::mpz_bytes "
";

%feature("docstring") lal::internal::__lal::move_mpz_to_mpz "
";

%feature("docstring") lal::internal::__lal::move_mpq_to_mpq "
";

%feature("docstring") lal::internal::__lal::move_mpz_to_mpq "

Overloaded function
-------------------
* `move_mpz_to_mpq(source, target)`  

* `move_mpz_to_mpq(source_n, source_d, target)`  
";

%feature("docstring") lal::internal::__lal::n_C_brute_force "

Overloaded function
-------------------
* `n_C_brute_force(g, pi={})`  

* `n_C_brute_force(g, pi={})`  
";

%feature("docstring") lal::internal::__lal::n_C_brute_force_list "

Overloaded function
-------------------
* `n_C_brute_force_list(g, pis)`  

* `n_C_brute_force_list(g, pis)`  
";

%feature("docstring") lal::internal::__lal::n_C_dynamic_programming "

Overloaded function
-------------------
* `n_C_dynamic_programming(g, pi={})`  

* `n_C_dynamic_programming(g, pi={})`  
";

%feature("docstring") lal::internal::__lal::n_C_dynamic_programming_list "

Overloaded function
-------------------
* `n_C_dynamic_programming_list(g, pis)`  

* `n_C_dynamic_programming_list(g, pis)`  
";

%feature("docstring") lal::internal::__lal::n_C_ladder "

Overloaded function
-------------------
* `n_C_ladder(g, pi={})`  

* `n_C_ladder(g, pi={})`  
";

%feature("docstring") lal::internal::__lal::n_C_ladder_list "

Overloaded function
-------------------
* `n_C_ladder_list(g, pis)`  

* `n_C_ladder_list(g, pis)`  
";

%feature("docstring") lal::internal::__lal::n_C_stack_based "
";

%feature("docstring") lal::internal::__lal::n_C_stack_based_list "
";

%feature("docstring") lal::internal::__lal::has_directed_cycles "
";

%feature("docstring") lal::internal::__lal::has_undirected_cycles "
";

%feature("docstring") lal::internal::__lal::E "
";

%feature("docstring") lal::internal::__lal::Q "
";

%feature("docstring") lal::internal::__lal::is_node_reachable_from "
";

%feature("docstring") lal::internal::__lal::level_sequence_to_ftree "

Overloaded function
-------------------
* `level_sequence_to_ftree(L, n, normalise=true, check=true) ->
    graphs::free_tree`  

* `level_sequence_to_ftree(L, n, normalise=true, check=true) ->
    graphs::free_tree`  
";

%feature("docstring") lal::internal::__lal::Prufer_sequence_to_ftree "

Overloaded function
-------------------
* `Prufer_sequence_to_ftree(seq, n, normalise=true, check=true) ->
    graphs::free_tree`  

* `Prufer_sequence_to_ftree(S, n, normalise=true, check=true) ->
    graphs::free_tree`  
";

%feature("docstring") lal::internal::__lal::linear_sequence_to_ftree "
";

%feature("docstring") lal::internal::__lal::linear_sequence_to_rtree "
";

%feature("docstring") lal::internal::__lal::Dmin_Pr__optimal_interval_of "
";

%feature("docstring") lal::internal::__lal::Dmin_Projective "
";

%feature("docstring") lal::internal::__lal::Dmin_Planar "
";

%feature("docstring") lal::internal::__lal::Dmin_Unconstrained_YS "
";

%feature("docstring") lal::internal::__lal::Dmin_Unconstrained_FC "
";

%feature("docstring") lal::internal::__lal::is_graph_a_tree "
";

%feature("docstring") lal::internal::__lal::make_arrangement_intervals "

Overloaded function
-------------------
* `make_arrangement_intervals(T, data)`  

* `make_arrangement_intervals(T, root, data)`  
";

%feature("docstring") lal::internal::__lal::get_edges_subtree "
";

%feature("docstring") lal::internal::__lal::get_size_subtrees "
";

%feature("docstring") lal::internal::__lal::calculate_bidirectional_sizes "
";

%feature("docstring") lal::internal::__lal::retrieve_centre "
";

%feature("docstring") lal::internal::__lal::retrieve_centroid "

Overloaded function
-------------------
* `retrieve_centroid(t, x, M, sizes_edge)`  

* `retrieve_centroid(t, x)`  

* `retrieve_centroid(t, M, sizes_edge)`  

* `retrieve_centroid(t)`  
";

%feature("docstring") lal::internal::__lal::classify_tree "
";

%feature("docstring") lal::internal::__lal::tree_diameter "
";

%feature("docstring") lal::internal::__lal::fast_non_iso "
";

%feature("docstring") lal::internal::__lal::assign_name_and_keep "
";

%feature("docstring") lal::internal::__lal::assign_name "
";

%feature("docstring") lal::internal::__lal::are_full_trees_isomorphic "
";

%feature("docstring") lal::internal::__lal::UnionFind_update_roots_add "
";

%feature("docstring") lal::internal::__lal::UnionFind_update_roots_remove "
";

%feature("docstring") lal::internal::__lal::get_bool_neighbours "
";

%feature("docstring") lal::internal::__lal::append_adjacency_lists "
";

%feature("docstring") lal::internal::__lal::UNUSED "
";

%feature("docstring") lal::internal::__lal::call_with_empty_arrangement "
";

%feature("docstring") lal::internal::__lal::make_array_with_value "
";

%feature("docstring") lal::internal::__lal::bit_sort_mem "
";

%feature("docstring") lal::internal::__lal::bit_sort "
";

%feature("docstring") lal::internal::__lal::counting_sort "

Overloaded function
-------------------
* `counting_sort(begin, end, largest_key_plus_1, key, mem)`  

* `counting_sort(begin, end, largest_key, upper_bound_size, key)`  
";

%feature("docstring") lal::internal::__lal::insertion_sort "
";

// File: namespacelal_1_1internal_1_1____lal.xml

%feature("docstring") lal::internal::__lal::move_from_source_to_target "
";

%feature("docstring") lal::internal::__lal::__find_cycle "
";

%feature("docstring") lal::internal::__lal::has_directed_cycles "
";

%feature("docstring") lal::internal::__lal::has_undirected_cycles "
";

%feature("docstring") lal::internal::__lal::__make_arrangement_intervals "

Overloaded function
-------------------
* `__make_arrangement_intervals(T, r, data, pos, arr)`  

* `__make_arrangement_intervals(T, parent, r, data, pos, arr)`  
";

%feature("docstring") lal::internal::__lal::get_size_subtrees "
";

%feature("docstring") lal::internal::__lal::calculate_bidirectional_sizes "
";

%feature("docstring") lal::internal::__lal::retrieve_centroid "
";

%feature("docstring") lal::internal::__lal::make_array_with_value_impl "
";

%feature("docstring") lal::internal::__lal::__bit_sort "
";

// File: namespacelal_1_1io.xml

%feature("docstring") lal::io::read_edge_list "

Overloaded function
-------------------
* `read_edge_list(filename, g, norm=true, check_norm=true)`  
    
    Reads a graph in edge list format.  

    This format consists of a list of all the graph's edges. Each edge is
    described as a pair of indices of the nodes at each end of the edge.  

    Nodes are usually labelled with indices starting at 0, so this value is
    accepted. The resulting number of nodes of the graph will be the maximum
    index in the file plus 1.  

    The current contents of the graph will be cleared and replaced by the
    contents of the file.  

    Parameters:
  
    * `filename` :  
        Name of the file.  
    * `g` :  
        Graph read from the file.  
    * `norm` :  
        Should the graph be normalised? See graphs::graph::is_normalised()  
    * `check_norm` :  
        If the graph is not to be normalised check whether or not the graph read
        is normalised.  

    Returns:
    False if the file could not be opened. True if the graph was read
    successfully.  

* `read_edge_list(filename, g, norm=true, check_norm=true)`  
    
    Reads a graph in edge list format.  

    This format consists of a list of all the graph's edges. Each edge is
    described as a pair of indices of the nodes at each end of the edge.  

    Nodes are usually labelled with indices starting at 0, so this value is
    accepted. The resulting number of nodes of the graph will be the maximum
    index in the file plus 1.  

    The current contents of the graph will be cleared and replaced by the
    contents of the file.  

    Parameters:
  
    * `filename` :  
        Name of the file.  
    * `g` :  
        Graph read from the file.  
    * `norm` :  
        Should the graph be normalised? See graphs::graph::is_normalised()  
    * `check_norm` :  
        If the graph is not to be normalised check whether or not the graph read
        is normalised.  

    Returns:
    False if the file could not be opened. True if the graph was read
    successfully.  
";

// File: namespacelal_1_1iterators.xml

// File: namespacelal_1_1linarr.xml

%feature("docstring") lal::linarr::mean_dependency_distance_1level_rational "

1-level Mean Dependency Distance :math:`MDD` over an ensemble of graphs.  

Given a list of graphs :math:`L` and a list of linear arrangements for each of them,
:math:`P`  computes the 1-level Mean Dependency Distance as the quotient of :math:`D`  the
sum of all the edge lengths of each graph, and of :math:`M` the sum of the number of
edges of all the graphs.  

Formally, given a list of graphs :math:`L = \\{L_i\\}_{i=1}^k` and a list of linear
arrangements :math:`\\P = \\{\\pi_i\\}_{i=1}^k`  computes :math:`D/M`  where  

*   :math:`D = \\sum_{i=1}^k D(L_i, \\pi_i)` is the sum of edge lengths of all graphs.  
*   :math:`M = \\sum_{i=1}^k 
E(L_i)
` is the sum of the number of edges of all
    graphs.  

Parameters
----------
* `L` :  
    List of input graphs.  
* `P` :  
    List of linear arrangements of the nodes :math:`P = \\{\\pi_i\\}_{i=1}^k`  When
    omitted, :math:`\\pi_I` is used for every graph.  

Returns
-------
Jing's and Liu's 1-level :math:`MDD` for an ensemble of graphs as an exact rational
value.  
";

%feature("docstring") lal::linarr::mean_dependency_distance_1level "

1-level Mean Dependency Distance :math:`MDD` over an ensemble of graphs.  

See mean_dependency_distance_1level_rational for details.  

Parameters
----------
* `L` :  
    List of input graphs.  
* `P` :  
    List of linear arrangements of the nodes :math:`P = \\{\\pi_i\\}_{i=1}^k`  When
    omitted, :math:`\\pi_I` is used for every graph.  

Returns
-------
Jing's and Liu's 1-level :math:`MDD` for an ensemble of graphs as a floating point
value.  
";

%feature("docstring") lal::linarr::mean_dependency_distance_2level_rational "

2-level Mean Dependency Distance :math:`MDD` over an ensemble of graphs.  

Given a list of graphs :math:`L` and a list of linear arrangements of the nodes for
each of them, :math:`P`  computes the 2-level Mean Dependency Distance, i.e., it
computes the average Mean Dependency Distance of the graphs in the list.  

Formally, given a list of graphs :math:`L = \\{L_i\\}_{i=1}^k` and a list of linear
arrangements :math:`P = \\{\\pi_i\\}_{i=1}^k`  computes :math:`(1/k)S_{<d>}`  where :math:`S_{<d>}
= \\sum_{i=1}^k MDD(L_i, \\pi_i)` is the sum of the mean dependency distances of
every graph (see mean_dependency_distance_rational for details on the definition
of the Mean Dependency Distance).  

Parameters
----------
* `L` :  
    List of input graphs.  
* `P` :  
    List of linear arrangements of the nodes :math:`P = \\{\\pi_i\\}_{i=1}^k`  When
    omitted, :math:`\\pi_I` is used for every graph.  

Returns
-------
Jing's and Liu's 2-level :math:`MDD` for an ensemble of graphs as an exact rational
value.  
";

%feature("docstring") lal::linarr::mean_dependency_distance_2level "

2-level Mean Dependency Distance :math:`MDD` over an ensemble of graphs.  

See mean_dependency_distance_2level_rational for details.  

Parameters
----------
* `L` :  
    List of input graphs.  
* `P` :  
    List of linear arrangements of the nodes :math:`L = \\{\\pi_i\\}_{i=1}^k`  When
    omitted, :math:`\\pi_I` is used for every graph.  

Returns
-------
Jing's and Liu's 2-level :math:`MDD` for an ensemble of graphs as a floating point
value.  
";

%feature("docstring") lal::linarr::n_crossings "

Overloaded function
-------------------
* `n_crossings(g, pi={}, A=algorithms_C::ladder)`  
    
    Computes the number of edge crossings in a linear arrangement.  

    Given a graph and a linear arrangements of its nodes, computes the number of
    edge crossings using the algorithm specified by the parameter *A*.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  
    * `A` :  
        Algorithm to use to compute the number of crossings. Default:
        algorithms_C::stack_based.  

    Returns:
    The number of crossings :math:`C`   

    pre: The preconditions of this function depend on the choice of algorithm.
        See the preconditions of each algorithm in algorithms_C.  

* `n_crossings(g, pi={}, A=algorithms_C::ladder)`  
    
    Computes the number of edge crossings in a linear arrangement.  

    Given a graph and a linear arrangements of its nodes, computes the number of
    edge crossings using the algorithm specified by the parameter *A*.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  
    * `A` :  
        Algorithm to use to compute the number of crossings. Default:
        algorithms_C::stack_based.  

    Returns:
    The number of crossings :math:`C`   

    pre: The preconditions of this function depend on the choice of algorithm.
        See the preconditions of each algorithm in algorithms_C.  
";

%feature("docstring") lal::linarr::n_crossings_list "

Overloaded function
-------------------
* `n_crossings_list(g, pis, A=algorithms_C::ladder)`  
    
    Computes the number of edge crossings in a linear arrangement.  

    Given a graph and a list of linear arrangements of its nodes, computes the
    number of edge crossings for each of the linear arrangements in the list
    using the algorithm specified by the parameter *A*.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pis` :  
        List of :math:`k` linear arrangements of the nodes :math:`\\Pi =
        \\{\\pi_i\\}_{i=1}^k`   
    * `A` :  
        Algorithm to use to compute the number of crossings. Default:
        algorithms_C::stack_based.  

    Returns:
    A list :math:`L` where :math:`L_i = C_{\\pi_i}(g)`   

    pre: None of the arrangements in *pis* can be empty.  

    pre: The preconditions of this function depend on the choice of algorithm.
        See the preconditions of each algorithm in algorithms_C.  

* `n_crossings_list(g, pis, A=algorithms_C::ladder)`  
    
    Computes the number of edge crossings in a linear arrangement.  

    Given a graph and a list of linear arrangements of its nodes, computes the
    number of edge crossings for each of the linear arrangements in the list
    using the algorithm specified by the parameter *A*.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pis` :  
        List of :math:`k` linear arrangements of the nodes :math:`\\Pi =
        \\{\\pi_i\\}_{i=1}^k`   
    * `A` :  
        Algorithm to use to compute the number of crossings. Default:
        algorithms_C::stack_based.  

    Returns:
    A list :math:`L` where :math:`L_i = C_{\\pi_i}(g)`   

    pre: None of the arrangements in *pis* can be empty.  

    pre: The preconditions of this function depend on the choice of algorithm.
        See the preconditions of each algorithm in algorithms_C.  
";

%feature("docstring") lal::linarr::approximate_C_rational "

Overloaded function
-------------------
* `approximate_C_rational(g, pi={})`  
    
    Approximates the number of crossings.  

    Given a linear arrangement, which determines the length of the edges,
    predict the number of crossings conditioned by the length of the edges in
    the linear arrangement. Implementation of [9]. If the arrangement is not
    specified, the identity arrangement is used.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    Approximation of the number of crossings :math:`E_s[C_G\\;
\\;\\delta]`   

* `approximate_C_rational(g, pi={})`  
    
    Approximates the number of crossings.  

    Given a linear arrangement, which determines the length of the edges,
    predict the number of crossings conditioned by the length of the edges in
    the linear arrangement. Implementation of [9]. If the arrangement is not
    specified, the identity arrangement is used.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    Approximation of the number of crossings :math:`E_s[C_G\\;
\\;\\delta]`   
";

%feature("docstring") lal::linarr::approximate_C "

Overloaded function
-------------------
* `approximate_C(g, pi={})`  
    
    Approximates the number of crossings.  

    See approximate_C_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The return value is a floating point value.  

* `approximate_C(g, pi={})`  
    
    Approximates the number of crossings.  

    See approximate_C_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The return value is a floating point value.  
";

%feature("docstring") lal::linarr::classify_tree_structure "

Computes the type of syntactic dependency tree.  

Given an undirected rooted tree and a linear arrangement of its nodes, computes
the class of projective structure the tree belongs to.  

Parameters
----------
* `t` :  
    Input tree.  
* `pi` :  
    Linear arrangement of the nodes. If :math:`\\pi[u]=p` then node *u* is placed in
    position *p* of the arrangement.  

Returns
-------
The class of projective structure. If the class could not be determined the
method returns syntactic_dependency_structure_type::none  
";

%feature("docstring") lal::linarr::sum_length_edges "

Overloaded function
-------------------
* `sum_length_edges(g, pi={})`  
    
    Computes the sum of the length of the edges in a linear arrangement.  

    Given a graph :math:`G` and a linear arrangement of its nodes :math:`\\pi`  computes the
    sum of the length of the graph's edges in the arrangement. Formally, this
    function computes the value :math:`D_{\\pi}(G)=\\sum_{uv\\in E(G)} 
\\pi(u) -
    \\pi(v)
`   

    If the arrangement is not specified, the identity arrangement is used.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The sum of edge lengths :math:`D`   

* `sum_length_edges(g, pi={})`  
    
    Computes the sum of the length of the edges in a linear arrangement.  

    Given a graph :math:`G` and a linear arrangement of its nodes :math:`\\pi`  computes the
    sum of the length of the graph's edges in the arrangement. Formally, this
    function computes the value :math:`D_{\\pi}(G)=\\sum_{uv\\in E(G)} 
\\pi(u) -
    \\pi(v)
`   

    If the arrangement is not specified, the identity arrangement is used.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The sum of edge lengths :math:`D`   
";

%feature("docstring") lal::linarr::mean_dependency_distance_rational "

Overloaded function
-------------------
* `mean_dependency_distance_rational(g, pi={})`  
    
    Computes the mean dependency distance :math:`MDD` as an exact rational value.  

    Given a graph :math:`G` and a linear arrangement of its nodes :math:`\\pi`  computes the
    average edge length, or the mean dependency distance (see [17]). Formally,
    it computes :math:`\\frac{D_{\\pi}(G)}{
E(G)
}`  See function sum_length_edges for
    further details on :math:`D_{\\pi}(G)`   

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    Jing's and Liu's :math:`MDD`   

* `mean_dependency_distance_rational(g, pi={})`  
    
    Computes the mean dependency distance :math:`MDD` as an exact rational value.  

    Given a graph :math:`G` and a linear arrangement of its nodes :math:`\\pi`  computes the
    average edge length, or the mean dependency distance (see [17]). Formally,
    it computes :math:`\\frac{D_{\\pi}(G)}{
E(G)
}`  See function sum_length_edges for
    further details on :math:`D_{\\pi}(G)`   

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    Jing's and Liu's :math:`MDD`   
";

%feature("docstring") lal::linarr::mean_dependency_distance "

Overloaded function
-------------------
* `mean_dependency_distance(g, pi={})`  
    
    Computes the mean dependency distance :math:`MDD` as a floating point value.  

    See mean_dependency_distance_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The return value is a floating point value.  

* `mean_dependency_distance(g, pi={})`  
    
    Computes the mean dependency distance :math:`MDD` as a floating point value.  

    See mean_dependency_distance_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `pi` :  
        Linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  

    Returns:
    The return value is a floating point value.  
";

%feature("docstring") lal::linarr::Dmin "

Overloaded function
-------------------
* `Dmin(t, a)`  
    
    Computes the minimum value of :math:`D` in rooted trees.  

    Calculates the minimum value of :math:`D` and returns a linear arrangement
    yielding this value. Such optimal value of :math:`D` depends on the choice of
    algorithm for its calculation.  

    Parameters:
  
    * `t` :  
        Input tree.  
    * `a` :  
        The algorithm to be chosen.  

    Returns:
    The minimum value of :math:`D` and an optimum arrangement.  

    pre: Input tree *t* must be a valid tree (see graphs::tree::is_tree()).  

    pre: This function has as extra preconditions those specified in the
        enumeration passed as parameter.  

* `Dmin(t, a)`  
    
    Computes the minimum value of :math:`D` in free trees.  

    Calculates the minimum value of :math:`D` and returns a linear arrangement
    yielding this value. Such optimal value of :math:`D` depends on the choice of
    algorithm for its calculation.  

    Parameters:
  
    * `t` :  
        Input tree.  
    * `a` :  
        The algorithm to be chosen.  

    Returns:
    The minimum value of :math:`D` and an optimum arrangement.  

    pre: Input tree *t* must be a valid tree (see graphs::tree::is_tree()).  

    pre: This function has as extra preconditions those specified in the
        enumeration passed as parameter.  
";

%feature("docstring") lal::linarr::compute_flux "

Computes the flux of a dependency tree.  

This function is implemented based on the explanations given in [18].  

Parameters
----------
* `t` :  
    Input rooted tree (or dependency tree).  
* `pi` :  
    A linear arrangement of the nodes. When omitted, :math:`\\pi_I` is used.  
";

%feature("docstring") lal::linarr::headedness_rational "

Computes the headedness of a directed graph as an exact rational number.  

Given a graph and a permutation of its nodes, the headedness :math:`h` is the ratio of
right-branching edges over the total amount of edges. More precisely, it is  

:math:`h = \\frac{r}{m}`  

where :math:`r` is the number of right-branching edges and :math:`m` is the number of edges
of the graph.  

A value of 0 indicates perfect left branching, and a value of 1 indicates
perfect right-branching.  

Parameters
----------
* `g` :  
    Input graph.  
* `pi` :  
    Permutation of the nodes. When omitted, :math:`\\pi_I` is used.  

Returns
-------
The headedness ratio as an exact rational number.  
";

%feature("docstring") lal::linarr::headedness "

Computes the headedness of a linearly arranged directed graph.  

See headedness_rational for details.  

Parameters
----------
* `g` :  
    Input graph.  
* `pi` :  
    Permutation of the nodes. When omitted, :math:`\\pi_I` is used.  

Returns
-------
The return value is a floating point value.  
";

%feature("docstring") lal::linarr::syntactic_dependency_structure_type_to_string "

Converts to a string a value of the enumeration
syntactic_dependency_structure_type.  
";

// File: namespacelal_1_1numeric.xml

%feature("docstring") lal::numeric::integer_from_ui "

Make an integer from a 64-bit unsigned integer value.  

Parameters
----------
* `n` :  
    Unsigned integer (basic type) number.  
";

%feature("docstring") lal::numeric::rational_from_ui "

Make a rational value from two 64-bit unsigned integers.  
";

// File: namespacelal_1_1properties.xml

%feature("docstring") lal::properties::expectation_C_rational "

Computes the the expectation of the first moment of C.  

Returns :math:`E[C]` as a rational value.  

Parameters
----------
* `g` :  
    The input graph.  

Returns
-------
The expected value of the number of crossings as a rational value.  
";

%feature("docstring") lal::properties::expectation_C "

Computes the the expectation of the first moment of C.  

See expectation_C_rational for details.  

Parameters
----------
* `g` :  
    The input graph.  

Returns
-------
The expected value of the number of crossings as a floating point value.  
";

%feature("docstring") lal::properties::variance_C_rational "

Computes the variance of the number of crossings of a graph.  

Computes :math:`V_{rla}[C]` on the given graph. This function implements the algorithm
in [3] for general graphs, which stems from the study in [2].  

Since there are many computations that can be resued, setting *reuse* to 'true'
can help speed up the algorithm. Warning: reusing memory might be too memory-
consuming for large graphs (handle with care).  

Parameters
----------
* `g` :  
    Input graph.  
* `reuse` :  
    The algorithm will reuse computations in order to compute the variance
    faster. Note: this might be too memory-consuming.  

Returns
-------
The exact value of :math:`V_{rla}[C]` as a rational value.  

pre: Method graphs::graph::is_normalised() must evaluate to true.  
";

%feature("docstring") lal::properties::variance_C "

Computes the variance of the number of crossings of a graph.  

See variance_C_rational for details.  

Parameters
----------
* `g` :  
    Input graph.  
* `reuse` :  
    The algorithm will reuse computations in order to compute the variance
    faster. Note: this might be too memory-consuming.  

Returns
-------
The exact value of :math:`V_{rla}[C]` as a rationafloating point value.  
";

%feature("docstring") lal::properties::variance_C_forest_rational "

Computes the variance of the number of crossings of a forest.  

Computes :math:`V_{rla}[C]` on the given forest. This function implements the
algorithm in [3] for forests, which stems from the study in [2].  

Complexity: time :math:`O(n)`  space :math:`O(n)`   

Parameters
----------
* `g` :  
    Input forest.  

Returns
-------
The exact value of :math:`V_{rla}[C]` as a rational value.  

pre: The input graph *g* is a forest.  
";

%feature("docstring") lal::properties::variance_C_forest "

Computes the variance of the number of crossings of a forest.  

See variance_C_forest_rational for details.  

Parameters
----------
* `g` :  
    Input forest.  

Returns
-------
The exact value of :math:`V_{rla}[C]` as a floating point value.  
";

%feature("docstring") lal::properties::variance_C_tree_rational "

Computes the variance of the number of crossings of a tree.  

Computes :math:`V_{rla}[C]` on the given tree. This function computes the simplified
formula of :math:`V_{rla}[C]` on general graphs for the case of trees. Complexity:
time :math:`O(n)`  space :math:`O(n)`   

Parameters
----------
* `g` :  
    Input tree.  

Returns
-------
The exact value of :math:`V_{rla}[C]` as a rational value.  
";

%feature("docstring") lal::properties::variance_C_tree "

Computes the variance of the number of crossings of a tree.  

See variance_C_tree_rational for details.  

Parameters
----------
* `g` :  
    Input tree.  

Returns
-------
The return value is a floating point value.  
";

%feature("docstring") lal::properties::expectation_D_rational "

Computes the the expectation of the first moment of D.  

This function uses the formulae derived in [15].  

Returns the value :math:`E[D]` as a rational value.  

Parameters
----------
* `g` :  
    The input graph.  

Returns
-------
The expected value of the sum of edge lengths as a rational value.  
";

%feature("docstring") lal::properties::expectation_D "

Computes the the expectation of the first moment of D.  

See expectation_D_rational for details.  

Parameters
----------
* `g` :  
    The input graph.  

Returns
-------
The expected value of the sum of edge lengths as a floating point value.  
";

%feature("docstring") lal::properties::variance_D_rational "

Computes the variance of the sum of the length of edges.  

Computes :math:`V[D]`   

This function uses the formula derived in [15].  

Parameters
----------
* `g` :  
    Input graph.  

Returns
-------
The exact value of :math:`V[D]` as a rational value.  
";

%feature("docstring") lal::properties::variance_D "

Computes the variance of the sum of the length of edges.  

See variance_D_rational for details.  

Parameters
----------
* `g` :  
    The input graph.  

Returns
-------
The exact value of :math:`V[D]` as a floating point value.  
";

%feature("docstring") lal::properties::mmt_degree_rational "

Overloaded function
-------------------
* `mmt_degree_rational(g, p)`  
    
    Computes the :math:`p` th moment of degree about zero of a graph as an exact
    rational value.  

    Computes the :math:`p` th moment of degree about zero, :math:`\\langle k^p \\rangle`  of
    a graph using:  

    :math:`\\langle k^p \\rangle = \\frac{1}{n} \\sum_{i=1}^n k_i^p `   

    where :math:`n` denotes the number of nodes of the graph and :math:`k_i` is the degree
    of vertex :math:`i`   

    Parameters:
  
    * `g` :  
        Input graph.  
    * `p` :  
        Moment of degree.  

    Returns:
    The :math:`p` th moment of the in-degree about 0 as a rational value.  

* `mmt_degree_rational(g, p)`  
    
    Computes the :math:`p` th moment of degree about zero of a directed graph as an
    exact rational value.  

    Computes the :math:`p` th moment of degree about zero, :math:`\\langle k^p \\rangle`  of
    a graph using:  

    :math:`\\langle k^p \\rangle = \\frac{1}{n} \\sum_{i=1}^n k_i^p `   

    where :math:`n` denotes the number of nodes of the graph and :math:`k_i` is the in-
    degree plus the out-degree of vertex :math:`i`   

    Parameters:
  
    * `g` :  
        Input graph.  
    * `p` :  
        Moment of degree.  

    Returns:
    The :math:`p` th moment of the in-degree about 0 as a rational value.  
";

%feature("docstring") lal::properties::mmt_degree "

Overloaded function
-------------------
* `mmt_degree(g, p)`  
    
    Computes the :math:`p` th moment of degree about zero of a directed graph as an
    exact rational value.  

    See mmt_degree_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `p` :  
        Moment of degree.  

    Returns:
    The :math:`p` th moment of the degree about 0 as a floating point value.  

* `mmt_degree(g, p)`  
    
    Computes the :math:`p` th moment of degree about zero of a directed graph as an
    exact rational value.  

    See mmt_degree_rational for details.  

    Parameters:
  
    * `g` :  
        Input graph.  
    * `p` :  
        Moment of degree.  

    Returns:
    The :math:`p` th moment of the degree about 0 as a floating point value.  
";

%feature("docstring") lal::properties::mmt_in_degree_rational "

Computes the :math:`p` th moment of in-degree about zero of a directed graph as an
exact rational value.  

Computes the :math:`p` th moment of in-degree about zero, :math:`\\langle k_{in}^p
\\rangle`  of a directed graph using:  

:math:`\\langle k_{in}^p \\rangle = \\frac{1}{n} \\sum_{i=1}^n k_{in, i}^p `   

where :math:`n` denotes the number of nodes of the graph.  

Parameters
----------
* `g` :  
    Input graph.  
* `p` :  
    Moment of degree.  

Returns
-------
The :math:`p` th moment of the in-degree about 0 as a rational value.  
";

%feature("docstring") lal::properties::mmt_in_degree "

Computes the :math:`p` th moment of in-degree about zero of a directed graph as an
exact rational value.  

See mmt_in_degree_rational for details.  

Parameters
----------
* `g` :  
    Input graph.  
* `p` :  
    Moment of degree.  

Returns
-------
The :math:`p` th moment of the in-degree about 0 as a floating point value.  
";

%feature("docstring") lal::properties::mmt_out_degree_rational "

Computes the :math:`p` th moment of out-degree about zero of a directed graph as an
exact rational value.  

Computes the :math:`p` th moment of out-degree about zero, :math:`\\langle k_{out}^p
\\rangle`  of a directed graph using:  

:math:`\\langle k_{out}^p \\rangle = \\frac{1}{n} \\sum_{i=1}^n k_{out, i}^p `   

where :math:`n` denotes the number of nodes of the graph.  

Parameters
----------
* `g` :  
    Input graph.  
* `p` :  
    Moment of degree.  

Returns
-------
The :math:`p` th moment of the out-degree about 0 as a rational value.  
";

%feature("docstring") lal::properties::mmt_out_degree "

Computes the :math:`p` th moment of out-degree about zero of a directed graph as an
exact rational value.  

See mmt_out_degree_rational for details.  

Parameters
----------
* `g` :  
    Input graph.  
* `p` :  
    Moment of degree.  

Returns
-------
The :math:`p` th moment of the out-degree about 0 as a floating point value.  
";

%feature("docstring") lal::properties::hubiness_rational "

Computes the hubiness coefficient as an exact rational number.  

The hubiness coefficient is defined as.  

:math:`h = \\frac{ \\langle k^2 \\rangle - \\langle k^2 \\rangle_{linear} } { \\langle
k^2 \\rangle_{star} - \\langle k^2 \\rangle_{linear} }`   

where :math:`\\langle k^2 \\rangle_{star}` and :math:`\\langle k^2 \\rangle_{linear}` are
the second moment of degree about 0 (see mmt_degree_rational) of a star and
linear tree respectively.  

See [8] for details.  

Parameters
----------
* `g` :  
    Input graph.  

Returns
-------
The hubiness coefficient as a rational value.  

pre: :math:`n > 3`   
";

%feature("docstring") lal::properties::hubiness "

Computes the hubiness coefficient as an exact rational number.  

See hubiness_rational for details.  

Parameters
----------
* `g` :  
    Input graph.  

Returns
-------
The hubiness coefficient as a floating point value.  
";

%feature("docstring") lal::properties::mean_hierarchical_distance_rational "

Mean Hierarchical Distance.  

The mean hierarchical distance is calculated as a mean of the different
hierarchical distances between each vertex and the root of the tree. The
hierarchical distance :math:`HD_u` of vertex :math:`u` is calculated as the number of edges
between the tree's root and :math:`u`  The result of this function is the mean of
these distances: :math:`MHD = \\frac{1}{n} \\sum_{u\\in V} HD_u`   

For furhter details see [17].  

Parameters
----------
* `t` :  
    Input rooted tree.  

Returns
-------
The Mean Hierarchical Distance of a rooted tree as a rational value.  
";

%feature("docstring") lal::properties::mean_hierarchical_distance "

Mean Hierarchical Distance.  

See mean_hierarchical_distance_rational for details.  

Parameters
----------
* `t` :  
    Input rooted tree.  

Returns
-------
The Mean Hierarchical Distance of a rooted tree as a floating point value.  
";

%feature("docstring") lal::properties::size_Q_integer "

Overloaded function
-------------------
* `size_Q_integer(g)`  
    
    Compute the size of :math:`Q(G)`   

    The set :math:`Q(G)` of a graph :math:`G` is the set of pairs of independent edges. Two
    edges are said to be independent if they do not share vertices. Therefore,
    this function returns the amount of independent edges of this undirected
    graph.  

    Parameters:
  
    * `g` :  
        Input graph.  

    Returns:
    The size of :math:`Q(G)` as an integer of arbitrary precision.  

* `size_Q_integer(g)`  
    
    Compute the size of :math:`Q(G)`   

    The set :math:`Q(G)` of a graph :math:`G` is the set of pairs of independent edges. Two
    edges are said to be independent if they do not share vertices. Therefore,
    this function returns the amount of independent edges of this directed
    graph.  

    Parameters:
  
    * `g` :  
        Input graph.  

    Returns:
    The size of :math:`Q(G)` as an integer of arbitrary precision.  
";

%feature("docstring") lal::properties::size_Q "

Overloaded function
-------------------
* `size_Q(g)`  
    
    Compute the size of :math:`Q(G)`   

    See size_Q_integer for details.  

    Parameters:
  
    * `g` :  
        Input graph.  

    Returns:
    The size of :math:`Q(G)` as a 64-bit integer.  

* `size_Q(g)`  
    
    Compute the size of :math:`Q(G)`   

    See size_Q_integer for details.  

    Parameters:
  
    * `g` :  
        Input graph.  

    Returns:
    The size of :math:`Q(G)` as a 64-bit integer.  
";

%feature("docstring") lal::properties::get_centre "

Overloaded function
-------------------
* `get_centre(t)`  
    
    Calculate the centre of a rooted tree.  

    Here, \"centre\" should not be confused with \"centroid\". The center is the
    set of (at most) two vertices that have minimum eccentricity. The centroid
    is the set of (at most) two vertices that have minimum weight, where the
    weight is the maximum size of the subtrees rooted at that vertex. See [13]
    (pages 35-36) for further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    A tuple of two values: the nodes in the centre. If the tree has a single
    central node, only the first node is valid and the second is assigned an
    invalid vertex index. It is guaranteed that the first vertex has smaller
    index value than the second.  

    pre: Method graphs::rooted_tree::is_tree returns true.  

* `get_centre(t)`  
    
    Calculate the centre of a free tree.  

    Here, \"centre\" should not be confused with \"centroid\". The center is the
    set of (at most) two vertices that have minimum eccentricity. The centroid
    is the set of (at most) two vertices that have minimum weight, where the
    weight is the maximum size of the subtrees rooted at that vertex. See [13]
    (pages 35-36) for further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    A tuple of two values: the nodes in the centre. If the tree has a single
    central node, only the first node is valid and the second is assigned an
    invalid vertex index. It is guaranteed that the first vertex has smaller
    index value than the second.  

    pre: Method graphs::rooted_tree::is_tree returns true.  
";

%feature("docstring") lal::properties::get_centroid "

Overloaded function
-------------------
* `get_centroid(t)`  
    
    Calculate the centroid of a rooted tree.  

    Here, \"centroid\" should not be confused with \"centre\". The centre is the
    set of (at most) two vertices that have minimum eccentricity. The centroid
    is the set of (at most) two vertices that have minimum weight, where the
    weight is the maximum size of the subtrees rooted at that vertex. In both
    case, if the set has two vertices then they are adjacent in the tree. See
    [13] (pages 35-36) for further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    A tuple of two values: the nodes in the centre. If the tree has a single
    central node, only the first node is valid and the second is assigned an
    invalid vertex index. It is guaranteed that the first vertex has smaller
    index value than the second.  

    pre: Method graphs::rooted_tree::is_tree returns true.  

* `get_centroid(t)`  
    
    Calculate the centroid of a free tree.  

    Here, \"centre\" should not be confused with \"centroid\". The center is the
    set of (at most) two vertices that have minimum eccentricity. The centroid
    is the set of (at most) two vertices that have minimum weight, where the
    weight is the maximum size of the subtrees rooted at that vertex. See [13]
    (pages 35-36) for further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    A tuple of two values: the nodes in the centre. If the tree has a single
    central node, only the first node is valid and the second is assigned an
    invalid vertex index. It is guaranteed that the first vertex has smaller
    index value than the second.  

    pre: Method graphs::rooted_tree::is_tree returns true.  
";

%feature("docstring") lal::properties::get_diameter "

Overloaded function
-------------------
* `get_diameter(t)`  
    
    Calculate the diameter of a free tree.  

    The diameter is defined as the longest shortest distance between every pair
    of vertices. The distance is calculated in number of edges; two adjacent
    vertices are at a distance 1 from each other. See [13] (pages 24, 35) for
    further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    The diameter of the input tree.  

* `get_diameter(t)`  
    
    Calculate the diameter of a free tree.  

    The diameter is defined as the longest shortest distance between every pair
    of vertices. The distance is calculated in number of edges; two adjacent
    vertices are at a distance 1 from each other. See [13] (pages 24, 35) for
    further details.  

    Parameters:
  
    * `t` :  
        Input tree.  

    Returns:
    The diameter of the input tree.  
";

// File: namespacelal_1_1utilities.xml

%feature("docstring") lal::utilities::are_trees_isomorphic "

Overloaded function
-------------------
* `are_trees_isomorphic(t1, t2)`  
    
    Isomorphism test for rooted trees.  

    Decides whether the input trees are isomorphic or not. Two trees :math:`t_1` and
    :math:`t_2` (or graphs in general) are isomorphic if there exists a mapping :math:`\\phi
    \\;:\\; V(t_1) \\longrightarrow V(t_2)` such that  

    :math:`\\forall u,v\\in V(t_1) \\; (u,v)\\in E(t_1) \\longleftrightarrow
    (\\phi(u),\\phi(v))\\in E(t_2)`  

    and :math:`\\phi(r_1)=r_2` where :math:`r_1` and :math:`r_2` are, respectively, the roots of
    :math:`t_1` and :math:`t_2`  Note that :math:`(u,v)` denotes a directed edge.  

    The algorithm implemented can be found in [1].  

    Parameters:
  
    * `t1` :  
        Input rooted tree.  
    * `t2` :  
        Input rooted tree.  

    Returns:
    Whether or not the input trees are isomorphic or not. If the rooted trees do
    not have both a valid edge orientation (see
    graphs::rooted_tree::is_orientation_valid) the trees are considered to be
    non-isomorphic.  

* `are_trees_isomorphic(t1, t2)`  
    
    Isomorphism test for free trees.  

    Decides whether the input trees are isomorphic or not. Two trees :math:`t_1` and
    :math:`t_2` (or graphs in general) are isomorphic if there exists a mapping :math:`\\phi
    \\;:\\; V(t_1) \\longrightarrow V(t_2)` such that  

    :math:`\\forall u,v\\in V(t_1) \\; uv\\in E(t_1) \\longleftrightarrow
    \\phi(u)\\phi(v)\\in E(t_2)`  

    The algorithm implemented can be found in [1].  

    Parameters:
  
    * `t1` :  
        Input free tree.  
    * `t2` :  
        Input free tree.  

    Returns:
    Whether or not the input trees are isomorphic.  
";

// File: namespacestd.xml

// File: C_8hpp.xml

// File: linarr_2C_8hpp.xml

// File: D_8hpp.xml

// File: linarr_2D_8hpp.xml

// File: definitions_8hpp.xml

// File: generate_8hpp.xml

// File: all__lab__free__trees_8hpp.xml

// File: all__lab__rooted__trees_8hpp.xml

// File: all__projective__arrangements_8hpp.xml

// File: all__ulab__free__trees_8hpp.xml

// File: all__ulab__rooted__trees_8hpp.xml

// File: rand__lab__free__trees_8hpp.xml

// File: rand__lab__rooted__trees_8hpp.xml

// File: rand__projective__arrangements_8hpp.xml

// File: rand__ulab__free__trees_8hpp.xml

// File: rand__ulab__rooted__trees_8hpp.xml

// File: tree__gen_8hpp.xml

// File: graphs_8hpp.xml

// File: directed__graph_8hpp.xml

// File: free__tree_8hpp.xml

// File: graph_8hpp.xml

// File: graphs_2output_8hpp.xml

// File: numeric_2output_8hpp.xml

// File: rooted__tree_8hpp.xml

// File: tree_8hpp.xml

// File: tree__type_8hpp.xml

// File: undirected__graph_8hpp.xml

// File: avl_8hpp.xml

// File: data__array_8hpp.xml

// File: gmp_2utils_8hpp.xml

// File: graphs_2utils_8hpp.xml

// File: algorithms__crossings_8hpp.xml

// File: cycles_8hpp.xml

// File: enumerate__sets_8hpp.xml

// File: reachability_8hpp.xml

// File: traversal_8hpp.xml

// File: convert__to__ftree_8hpp.xml

// File: convert__to__rtree_8hpp.xml

// File: internal_2graphs_2trees_2Dmin_8hpp.xml

// File: linarr_2Dmin_8hpp.xml

// File: is__tree_8hpp.xml

// File: make__arrangement_8hpp.xml

// File: retrieve__subtree_8hpp.xml

// File: size__subtrees_8hpp.xml

// File: internal_2graphs_2trees_2tree__centre_8hpp.xml

// File: properties_2tree__centre_8hpp.xml

// File: internal_2graphs_2trees_2tree__centroid_8hpp.xml

// File: properties_2tree__centroid_8hpp.xml

// File: tree__classification_8hpp.xml

// File: internal_2graphs_2trees_2tree__diameter_8hpp.xml

// File: properties_2tree__diameter_8hpp.xml

// File: internal_2graphs_2trees_2tree__isomorphism_8hpp.xml

// File: utilities_2tree__isomorphism_8hpp.xml

// File: union__find_8hpp.xml

// File: macros_8hpp.xml

// File: make__array__with__value_8hpp.xml

// File: sorted__vector_8hpp.xml

// File: bit__sort_8hpp.xml

// File: counting__sort_8hpp.xml

// File: insertion__sort_8hpp.xml

// File: io_8hpp.xml

// File: basic__output_8hpp.xml

// File: dataset__error_8hpp.xml

// File: edge__list_8hpp.xml

// File: treebank__dataset__processor_8hpp.xml

// File: treebank__dataset__reader_8hpp.xml

// File: treebank__reader_8hpp.xml

// File: iterators_8hpp.xml

// File: E__iterator_8hpp.xml

// File: Q__iterator_8hpp.xml

// File: lal__version_8hpp.xml

// File: linarr_8hpp.xml

// File: 1level_8hpp.xml

// File: 2level_8hpp.xml

// File: algorithms__C_8hpp.xml

// File: algorithms__Dmin_8hpp.xml

// File: classify__syntactic__dependency__structure_8hpp.xml

// File: dependency__flux_8hpp.xml

// File: flux_8hpp.xml

// File: headedness_8hpp.xml

// File: syntactic__dependency__structure__type_8hpp.xml

// File: namespaces_8hpp.xml

// File: numeric_8hpp.xml

// File: integer_8hpp.xml

// File: integer__output_8hpp.xml

// File: rational_8hpp.xml

// File: rational__output_8hpp.xml

// File: properties_8hpp.xml

// File: C__rla_8hpp.xml

// File: D__rla_8hpp.xml

// File: degrees_8hpp.xml

// File: mean__hierarchical__distance_8hpp.xml

// File: Q_8hpp.xml

// File: utilities_8hpp.xml

// File: citelist.xml

// File: dir_451d9360bed40d6c41f5da8ac2577526.xml

// File: dir_17f3f98810adab8b74ec8b55070ffa65.xml

// File: dir_0383c532a5a471f242ed36a602f58c32.xml

// File: dir_0cb12f45fbb6fac7052f7e7aaeaf0dc8.xml

// File: dir_c376e08424b785d5cf62d5946d9fdd28.xml

// File: dir_b39624fd278d515b814da31c698039ef.xml

// File: dir_9cbe99698a9bc0696b4b82d9c6ec1184.xml

// File: dir_8f631ac29b6730c95cdd9d587311e2d3.xml

// File: dir_fc94e3b67d90f4da409ada728f5b788a.xml

// File: dir_69ee5632e626b72508b67b6210d102f4.xml

// File: dir_cc0cd4d6d384fc7709f97ff1416f278a.xml

// File: dir_9c0271f0057b057f4e3b43cfb50c1251.xml

// File: dir_30632435f58303527eb29d54da790cfc.xml

// File: dir_a85b0b86580427796d239343390acb8f.xml

// File: indexpage.xml

